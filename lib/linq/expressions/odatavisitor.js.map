{"version":3,"file":"odatavisitor.js","sourceRoot":"","sources":["../../../src/linq/expressions/odatavisitor.ts"],"names":[],"mappings":"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","sourcesContent":["import { IExpression, Expression, ExpressionType } from './expression';\nimport { ILiteralExpression, LiteralExpression } from './literalexpression';\nimport { ICompoundExpression } from './compoundexpression';\nimport { IIdentifierExpression, IdentifierExpression } from './identifierexpression';\nimport { IMemberExpression, MemberExpression } from './memberexpression';\nimport { IMethodExpression, MethodExpression } from './methodexpression';\nimport { IUnaryExpression, UnaryExpression, UnaryOperatorType, UnaryAffixType } from './unaryexpression';\nimport { IBinaryExpression, BinaryExpression, BinaryOperatorType } from './binaryexpression';\nimport { ILogicalExpression, LogicalExpression, LogicalOperatorType } from './logicalexpression';\nimport { IConditionalExpression } from './conditionalexpression';\nimport { IArrayExpression, ArrayExpression } from './arrayexpression';\n\nimport { LambdaExpression } from './lambdaexpression';\nimport { ReducerVisitor } from './reducervisitor';\n\nexport class ODataVisitor extends ReducerVisitor {\n    constructor(private it?: Object) {\n        super();\n    }\n    \n    public visitOData(filter: string): IExpression {\n        return super.visitOData(filter);\n    }\n\n    public visitMethod(expression: IMethodExpression): IExpression {\n        let parameters = expression.parameters.map((arg) => arg.accept(this)),\n            caller = null;\n\n        if (parameters.every(expression => expression.type == ExpressionType.Literal) == true) {\n            // all parameters is a literal, eg; solvable\n            let params: Array<any> = parameters.map(expr => (<LiteralExpression>expr).value);\n\n            switch (expression.name) {\n                // String Functions\n                case 'substringof': // bool substringof(string po, string p1)\n                    if ((params.length == 2 && params.every(p => typeof p == 'string')) == false)\n                        throw new Error('Method \"substringof\" requires parameters of (string, string), but got \"' + params.map(p => typeof p).join(', ') + '\"');\n\n                    return new LiteralExpression(String(params[0]).indexOf(String(params[1])) >= 0);\n\n                case 'endswith': // bool endswith(string p0, string p1)\n                    if ((params.length == 2 && params.every(p => typeof p == 'string')) == false)\n                        throw new Error('Method \"endswith\" requires parameters of (string, string), but got \"' + params.map(p => typeof p).join(', ') + '\"');\n\n                    return new LiteralExpression(String(params[0]).endsWith(String(params[1])));\n\n                case 'startswith': // bool startswith(string p0, string p1)\n                    if ((params.length == 2 && params.every(p => typeof p == 'string')) == false)\n                        throw new Error('Method \"startswith\" requires parameters of (string, string), but got \"' + params.map(p => typeof p).join(', ') + '\"');\n\n                    return new LiteralExpression(String(params[0]).startsWith(String(params[1])));\n\n                case 'length': // int length(string p0)\n                    if ((params.length == 1 && params.every(p => typeof p == 'string')) == false)\n                        throw new Error('Method \"length\" requires parameters of (string), but got \"' + params.map(p => typeof p).join(', ') + '\"');\n\n                    return new LiteralExpression(String(params[0]).length);\n\n                case 'indexof': // int indexof(string p0, string p1)\n                    if ((params.length == 2 && params.every(p => typeof p == 'string')) == false)\n                        throw new Error('Method \"indexof\" requires parameters of (string, string), but got \"' + params.map(p => typeof p).join(', ') + '\"');\n\n                    return new LiteralExpression(String(params[0]).indexOf(String(params[1])));\n\n                case 'replace': // string replace(string p0, string find, string replace)\n                    if ((params.length == 3 && params.every(p => typeof p == 'string')) == false)\n                        throw new Error('Method \"replace\" requires parameters of (string, string, string), but got \"' + params.map(p => typeof p).join(', ') + '\"');\n\n                    return new LiteralExpression(String(params[0]).replace(String(params[1]), String(params[2])));\n\n                case 'substring': // string substring(string p0, int pos, int? length)\n                    if ((params.length >= 2 && typeof params[0] == \"string\" && typeof params[1] == 'number' && (params.length == 3 ? typeof params[3] == 'number' : true)) == false)\n                        throw new Error('Method \"replace\" requires parameters of (string, int, int?), but got \"' + params.map(p => typeof p).join(', ') + '\"');\n\n                    return new LiteralExpression(String(params[0]).replace(String(params[1]), String(params[2])));\n                    \n                case 'tolower': // string tolower(string p0)\n                    if ((params.length == 1 && params.every(p => typeof p == 'string')) == false)\n                        throw new Error('Method \"tolower\" requires parameters of (string), but got \"' + params.map(p => typeof p).join(', ') + '\"');\n\n                    return new LiteralExpression(String(params[0]).toLowerCase());\n\n                case 'toupper': // string toupper(string p0)\n                    if ((params.length == 1 && params.every(p => typeof p == 'string')) == false)\n                        throw new Error('Method \"toupper\" requires parameters of (string), but got \"' + params.map(p => typeof p).join(', ') + '\"');\n\n                    return new LiteralExpression(String(params[0]).toUpperCase());\n\n                case 'trim': // string trim(string p0)\n                    if ((params.length == 1 && params.every(p => typeof p == 'string')) == false)\n                        throw new Error('Method \"trim\" requires parameters of (string), but got \"' + params.map(p => typeof p).join(', ') + '\"');\n\n                    return new LiteralExpression(String(params[0]).trim());\n\n                case 'concat': // string concat(string p0, string p1)\n                    if ((params.length == 2 && params.every(p => typeof p == 'string')) == false)\n                        throw new Error('Method \"concat\" requires parameters of (string, string), but got \"' + params.map(p => typeof p).join(', ') + '\"');\n\n                    return new LiteralExpression(String(params[0]) + String(params[1]));\n\n                // Date Functions\n                case 'day': // int day(DateTime p0)\n                case 'hour': // int hour(DateTime p0)\n                case 'minute': // int minute(DateTime p0)\n                case 'month': // int month(DateTime p0)\n                case 'second': // int second(DateTime p0)\n                case 'year': // int year(DateTime p0)\n                    throw new Error('OData visitor does not support Date Functions at this time');\n\n                // Math Functions\n                case 'round': // number round(number p0)\n                    if ( (params.length == 1 && params.every(p => typeof p == 'number')) == false)\n                        throw new Error('Method \"round\" requires parameters of (number), but got \"' + params.map(p => typeof p).join(', ') + '\"');\n\n                    return new LiteralExpression( Math.round( Number(params[0]) ));\n\n                case 'floor': // number floor(number p0)\n                    if ((params.length == 1 && params.every(p => typeof p == 'number')) == false)\n                        throw new Error('Method \"floor\" requires parameters of (number), but got \"' + params.map(p => typeof p).join(', ') + '\"');\n\n                    return new LiteralExpression(Math.floor(Number(params[0])));\n\n                case 'ceiling': // number ceiling(number p0)\n                    if ((params.length == 1 && params.every(p => typeof p == 'number')) == false)\n                        throw new Error('Method \"ceiling\" requires parameters of (number), but got \"' + params.map(p => typeof p).join(', ') + '\"');\n\n                    return new LiteralExpression(Math.ceil(Number(params[0])));\n\n                // Type Functions\n                case 'isof': // bool IsOf(type p0) | bool IsOf(expression p0, type p1)\n\n                default:\n                    throw new Error('OData visitor does not support function \"' + expression.name + '\"');\n            }\n        }\n\n        return new MethodExpression(expression.name, parameters, caller);\n    }\n\n    public static evaluate(expression: IExpression, it: Object): any {\n        let reducer = new ODataVisitor(it),\n            resultExpression = reducer.visit(expression),\n            result = reducer.evaluate(resultExpression);\n\n        return result;\n    }\n\n    protected evaluate(expression: IExpression): any {\n        var value: any = null;\n\n        switch (expression.type) {\n            case ExpressionType.Identifier:\n                let identifier = (<IIdentifierExpression>expression);\n\n                if (this.it != null && this.it.hasOwnProperty(identifier.name) == true)\n                    return this.it[identifier.name];\n\n                break;\n\n            default:\n                value = super.evaluate(expression);\n                break;\n        }\n\n        return value;\n    }\n}"]}