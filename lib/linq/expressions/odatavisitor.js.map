{"version":3,"file":"odatavisitor.js","sourceRoot":"","sources":["../../../src/linq/expressions/odatavisitor.ts"],"names":[],"mappings":"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","sourcesContent":["import { IExpression, Expression, ExpressionType } from './expression';\nimport { ILiteralExpression, LiteralExpression } from './literalexpression';\nimport { ICompoundExpression } from './compoundexpression';\nimport { IIdentifierExpression, IdentifierExpression } from './identifierexpression';\nimport { IMemberExpression, MemberExpression } from './memberexpression';\nimport { IMethodExpression, MethodExpression } from './methodexpression';\nimport { IUnaryExpression, UnaryExpression, UnaryOperatorType, UnaryAffixType } from './unaryexpression';\nimport { IBinaryExpression, BinaryExpression, BinaryOperatorType } from './binaryexpression';\nimport { ILogicalExpression, LogicalExpression, LogicalOperatorType } from './logicalexpression';\nimport { IConditionalExpression } from './conditionalexpression';\nimport { IArrayExpression, ArrayExpression } from './arrayexpression';\n\nimport { LambdaExpression } from './lambdaexpression';\nimport { ReducerVisitor } from './reducervisitor';\n\nexport class ODataVisitor extends ReducerVisitor {\n    constructor(private _it?: Object) {\n        super();\n    }\n    \n    public visitOData(filter: string): IExpression {\n        return super.visitOData(filter);\n    }\n\n    public get it(): string {\n        return \"\";\n    }\n\n    public visitMethod(expression: IMethodExpression): IExpression {\n        let parameters = expression.parameters.map((arg) => arg.accept(this)),\n            caller: IExpression = undefined,\n            name: string = undefined\n\n        \n        let params: Array<any>;\n\n        // routine to get all parameters that is a literal, eg; solvable\n        let getParams = (expression: IMethodExpression, ...typeofs: Array<string>) => {\n            let params: Array<any> = null,\n                getType = (t) => {\n                    if (typeof t == 'object') {\n                        if (t.getTime && t.getTime() >= 0)\n                            return 'date';\n                    }\n\n                    return typeof t;\n                };\n\n            try {\n                if (parameters.every(expression => expression.type == ExpressionType.Literal) == true) {\n                    params = parameters.map(expr => (<LiteralExpression>expr).value);\n\n                    if (new RegExp('^' + typeofs.map(t => t.endsWith('?') ? '(' + t.slice(0, -1) + ')?' : t).join(';') + ';?$').test(params.map(p => getType(p)).join(';') + ';') == false)\n                        throw new TypeError(params.map(p => getType(p)).join(', '));\n                }\n                else if ((parameters.length == typeofs.length) == false) {\n                    throw new Error();\n                }\n            }\n            catch (ex) {\n                throw new Error('Method \"' + expression.name + '\" requires parameters of (' + typeofs.join(', ') + ')' + (ex.name == 'TypeError' ? ', but got \"' + ex.message + '\"' : ''));\n            }\n\n            return params;\n        }\n\n        switch (expression.name) {\n            // String Functions\n            case 'substringof': // bool substringof(string po, string p1)\n                if ((params = getParams(expression, 'string', 'string')) != null)\n                    return new LiteralExpression(String(params[0]).indexOf(String(params[1])) >= 0);\n\n                break;\n\n            case 'endswith': // bool endswith(string p0, string p1)\n                if ((params = getParams(expression, 'string', 'string')) != null)\n                    return new LiteralExpression(String(params[0]).endsWith(String(params[1])));\n\n                break;\n\n            case 'startswith': // bool startswith(string p0, string p1)\n                if ((params = getParams(expression, 'string', 'string')) != null)\n                    return new LiteralExpression(String(params[0]).startsWith(String(params[1])));\n\n                break;\n\n            case 'length': // int length(string p0)\n                if ((params = getParams(expression, 'string')) != null)\n                    return new LiteralExpression(String(params[0]).length);\n                \n                break;\n\n            case 'indexof': // int indexof(string p0, string p1)\n                if ((params = getParams(expression, 'string', 'string')) != null)\n                    return new LiteralExpression(String(params[0]).indexOf(String(params[1])));\n\n                break;\n\n            case 'replace': // string replace(string p0, string find, string replace)\n                if ((params = getParams(expression, 'string', 'string', 'string')) != null)\n                    return new LiteralExpression(String(params[0]).replace(String(params[1]), String(params[2])));\n\n                break;\n\n            case 'substring': // string substring(string p0, int pos, int? length)\n                if ((params = getParams(expression, 'string', 'number', 'number?')) != null)\n                    return new LiteralExpression(String(params[0]).replace(String(params[1]), String(params[2])));\n\n                break;\n                    \n            case 'tolower': // string tolower(string p0)\n                if ((params = getParams(expression, 'string')) != null)\n                    return new LiteralExpression(String(params[0]).toLowerCase());\n\n                break;\n\n            case 'toupper': // string toupper(string p0)\n                if ((params = getParams(expression, 'string')) != null)\n                    return new LiteralExpression(String(params[0]).toUpperCase());\n\n                break;\n\n            case 'trim': // string trim(string p0)\n                if ((params = getParams(expression, 'string')) != null)\n                    return new LiteralExpression(String(params[0]).trim());\n\n                break;\n\n            case 'concat': // string concat(string p0, string p1)\n                if ((params = getParams(expression, 'string', 'string')) != null)\n                    return new LiteralExpression(String(params[0]) + String(params[1]));\n\n                break;\n\n            // Date Functions\n            case 'day': // int day(DateTime p0)\n                if ((params = getParams(expression, 'date')) != null)\n                    return new LiteralExpression((<Date>params[0]).getDate());\n\n                break;\n                        \n            case 'hour': // int hour(DateTime p0)\n                if ((params = getParams(expression, 'date')) != null)\n                    return new LiteralExpression((<Date>params[0]).getUTCHours());\n\n                break;\n\n            case 'minute': // int minute(DateTime p0)\n                if ((params = getParams(expression, 'date')) != null)\n                    return new LiteralExpression((<Date>params[0]).getUTCMinutes());\n\n                break;\n\n            case 'month': // int month(DateTime p0)\n                if ((params = getParams(expression, 'date')) != null)\n                    return new LiteralExpression((<Date>params[0]).getMonth() + 1);\n\n                break;\n\n            case 'second': // int second(DateTime p0)\n                if ((params = getParams(expression, 'date')) != null)\n                    return new LiteralExpression((<Date>params[0]).getSeconds());\n\n                break;\n\n            case 'year': // int year(DateTime p0)\n                if ((params = getParams(expression, 'date')) != null)\n                    return new LiteralExpression((<Date>params[0]).getFullYear());\n\n                break;\n\n            // Math Functions\n            case 'round': // number round(number p0)\n                if ((params = getParams(expression, 'number')) != null)\n                    return new LiteralExpression(Math.round(Number(params[0])));\n\n                break;\n\n            case 'floor': // number floor(number p0)\n                if ((params = getParams(expression, 'number')) != null)\n                    return new LiteralExpression(Math.floor(Number(params[0])));\n\n                break;\n\n            case 'ceiling': // number ceiling(number p0)\n                if ((params = getParams(expression, 'number')) != null)\n                    return new LiteralExpression(Math.ceil(Number(params[0])));\n\n                break;\n\n            // Type Functions\n            //case 'isof': // bool IsOf(type p0) | bool IsOf(expression p0, type p1)\n\n            default:\n                throw new Error('OData visitor does not support function \"' + expression.name + '\"');\n        }\n\n        return new MethodExpression(expression.name, parameters, caller);\n    }\n\n    public static evaluate(expression: IExpression, it: Object): any {\n        let reducer = new ODataVisitor(it),\n            resultExpression = reducer.visit(expression),\n            result = reducer.evaluate(resultExpression);\n\n        return result;\n    }\n\n    protected evaluate(expression: IExpression, it: Object = null): any {\n        var value: any = null;\n\n        if (it == null)\n            it = this._it;\n\n        switch (expression.type) {\n            case ExpressionType.Identifier:\n                let identifier = (<IIdentifierExpression>expression);\n\n                if (it != null && it.hasOwnProperty(identifier.name) == true) {\n                    value = it[identifier.name];\n                }\n                break;\n\n            case ExpressionType.Member:\n                let member = <IMemberExpression>expression,\n                    name: string;\n\n                if (it != null) {\n                    if (member.object.type == ExpressionType.Identifier && it.hasOwnProperty(name = (<IIdentifierExpression>member.object).name) && typeof it[name] == 'object')\n                        value = this.evaluate(member.property, it[name]);\n                }\n\n                break;\n            \n            default:\n                value = super.evaluate(expression);\n                break;\n        }\n\n        return value;\n    }\n}"]}