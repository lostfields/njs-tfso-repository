{"version":3,"file":"odatavisitor.js","sourceRoot":"","sources":["../../../src/linq/expressions/odatavisitor.ts"],"names":[],"mappings":"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","sourcesContent":["import { IExpression, Expression, ExpressionType } from './expression';\nimport { ILiteralExpression, LiteralExpression } from './literalexpression';\nimport { ICompoundExpression } from './compoundexpression';\nimport { IIdentifierExpression, IdentifierExpression } from './identifierexpression';\nimport { IMemberExpression, MemberExpression } from './memberexpression';\nimport { IMethodExpression, MethodExpression } from './methodexpression';\nimport { IUnaryExpression, UnaryExpression, UnaryOperatorType, UnaryAffixType } from './unaryexpression';\nimport { IBinaryExpression, BinaryExpression, BinaryOperatorType } from './binaryexpression';\nimport { ILogicalExpression, LogicalExpression, LogicalOperatorType } from './logicalexpression';\nimport { IConditionalExpression } from './conditionalexpression';\nimport { IArrayExpression, ArrayExpression } from './arrayexpression';\n\nimport { LambdaExpression } from './lambdaexpression';\nimport { ReducerVisitor } from './reducervisitor';\n\nexport class ODataVisitor extends ReducerVisitor {\n    constructor() {\n        super();\n    }\n    \n    public visitOData(filter: string): IExpression {\n        return super.visitOData(filter);\n    }\n\n    public get it(): string {\n        return \"\";\n    }\n\n    public visitMethod(expression: IMethodExpression): IExpression {\n        let parameters = expression.parameters.map((arg) => arg.accept(this)),\n            caller: IExpression = undefined,\n            name: string = undefined\n\n        \n        let params: Array<any>;\n\n        // routine to get all parameters that is a literal, eg; solvable\n        let getParams = (expression: IMethodExpression, ...typeofs: Array<string>) => {\n            let params: Array<any> = null,\n                getType = (t) => {\n                    if (typeof t == 'object') {\n                        if (t.getTime && t.getTime() >= 0)\n                            return 'date';\n                    }\n\n                    return typeof t;\n                };\n\n            try {\n                if (parameters.every(expression => expression.type == ExpressionType.Literal) == true) {\n                    params = parameters.map(expr => (<LiteralExpression>expr).value);\n\n                    if (new RegExp('^' + typeofs.map(t => t.endsWith('?') ? '(' + t.slice(0, -1) + ')?' : t).join(';') + ';?$').test(params.map(p => getType(p)).join(';') + ';') == false)\n                        throw new TypeError(params.map(p => getType(p)).join(', '));\n                }\n                else if ((parameters.length == typeofs.length) == false) {\n                    throw new Error();\n                }\n            }\n            catch (ex) {\n                throw new Error('Method \"' + expression.name + '\" requires parameters of (' + typeofs.join(', ') + ')' + (ex.name == 'TypeError' ? ', but got \"' + ex.message + '\"' : ''));\n            }\n\n            return params;\n        }\n\n        switch (expression.name) {\n            // String Functions\n            case 'substringof': // bool substringof(string po, string p1)\n                if ((params = getParams(expression, 'string', 'string')) != null)\n                    return new LiteralExpression(String(params[0]).indexOf(String(params[1])) >= 0);\n\n                break;\n\n            case 'endswith': // bool endswith(string p0, string p1)\n                if ((params = getParams(expression, 'string', 'string')) != null)\n                    return new LiteralExpression(String(params[0]).endsWith(String(params[1])));\n\n                break;\n\n            case 'startswith': // bool startswith(string p0, string p1)\n                if ((params = getParams(expression, 'string', 'string')) != null)\n                    return new LiteralExpression(String(params[0]).startsWith(String(params[1])));\n\n                break;\n\n            case 'length': // int length(string p0)\n                if ((params = getParams(expression, 'string')) != null)\n                    return new LiteralExpression(String(params[0]).length);\n                \n                break;\n\n            case 'indexof': // int indexof(string p0, string p1)\n                if ((params = getParams(expression, 'string', 'string')) != null)\n                    return new LiteralExpression(String(params[0]).indexOf(String(params[1])));\n\n                break;\n\n            case 'replace': // string replace(string p0, string find, string replace)\n                if ((params = getParams(expression, 'string', 'string', 'string')) != null)\n                    return new LiteralExpression(String(params[0]).replace(String(params[1]), String(params[2])));\n\n                break;\n\n            case 'substring': // string substring(string p0, int pos, int? length)\n                if ((params = getParams(expression, 'string', 'number', 'number?')) != null)\n                    return new LiteralExpression(String(params[0]).replace(String(params[1]), String(params[2])));\n\n                break;\n                    \n            case 'tolower': // string tolower(string p0)\n                if ((params = getParams(expression, 'string')) != null)\n                    return new LiteralExpression(String(params[0]).toLowerCase());\n\n                break;\n\n            case 'toupper': // string toupper(string p0)\n                if ((params = getParams(expression, 'string')) != null)\n                    return new LiteralExpression(String(params[0]).toUpperCase());\n\n                break;\n\n            case 'trim': // string trim(string p0)\n                if ((params = getParams(expression, 'string')) != null)\n                    return new LiteralExpression(String(params[0]).trim());\n\n                break;\n\n            case 'concat': // string concat(string p0, string p1)\n                if ((params = getParams(expression, 'string', 'string')) != null)\n                    return new LiteralExpression(String(params[0]) + String(params[1]));\n\n                break;\n\n            // Date Functions\n            case 'day': // int day(DateTime p0)\n                if ((params = getParams(expression, 'date')) != null)\n                    return new LiteralExpression((<Date>params[0]).getDate());\n\n                break;\n                        \n            case 'hour': // int hour(DateTime p0)\n                if ((params = getParams(expression, 'date')) != null)\n                    return new LiteralExpression((<Date>params[0]).getUTCHours());\n\n                break;\n\n            case 'minute': // int minute(DateTime p0)\n                if ((params = getParams(expression, 'date')) != null)\n                    return new LiteralExpression((<Date>params[0]).getUTCMinutes());\n\n                break;\n\n            case 'month': // int month(DateTime p0)\n                if ((params = getParams(expression, 'date')) != null)\n                    return new LiteralExpression((<Date>params[0]).getMonth() + 1);\n\n                break;\n\n            case 'second': // int second(DateTime p0)\n                if ((params = getParams(expression, 'date')) != null)\n                    return new LiteralExpression((<Date>params[0]).getSeconds());\n\n                break;\n\n            case 'year': // int year(DateTime p0)\n                if ((params = getParams(expression, 'date')) != null)\n                    return new LiteralExpression((<Date>params[0]).getFullYear());\n\n                break;\n\n            // Math Functions\n            case 'round': // number round(number p0)\n                if ((params = getParams(expression, 'number')) != null)\n                    return new LiteralExpression(Math.round(Number(params[0])));\n\n                break;\n\n            case 'floor': // number floor(number p0)\n                if ((params = getParams(expression, 'number')) != null)\n                    return new LiteralExpression(Math.floor(Number(params[0])));\n\n                break;\n\n            case 'ceiling': // number ceiling(number p0)\n                if ((params = getParams(expression, 'number')) != null)\n                    return new LiteralExpression(Math.ceil(Number(params[0])));\n\n                break;\n\n            // Type Functions\n            //case 'isof': // bool IsOf(type p0) | bool IsOf(expression p0, type p1)\n\n            default:\n                throw new Error('OData visitor does not support function \"' + expression.name + '\"');\n        }\n\n        return new MethodExpression(expression.name, parameters, caller);\n    }\n\n    public evaluate(expression: IExpression, it: Object = null): IExpression {\n        if (expression == null)\n            return null;\n\n        switch (expression.type)\n        {\n            case ExpressionType.Literal: {\n                let literal = (<ILiteralExpression>expression);\n\n                if (typeof (literal.value) == 'string')\n                {\n                    if (/(\\d{4}-\\d{2}-\\d{2}(?:T\\d{2}:\\d{2}(?::\\d{2}(?:\\.\\d{1,3})?)?)?(?:Z|[+-]\\d{2}:\\d{2})?)/i.test(literal.value)) // check for date for handyness? but it takes some resources as ops/sec goes from 400k to 300k\n                        return new LiteralExpression(new Date(literal.value));\n                }\n\n                break;\n            }\n\n            default:\n                return super.evaluate(expression, it);\n\n        }\n\n        return expression;\n    }\n\n    public static evaluate(expression: string, it?: Object): any\n    public static evaluate(expression: IExpression, it?: Object): any\n    public static evaluate(expression: IExpression | string, it: Object = null): any {\n        let reducer = new ODataVisitor(),\n            result: IExpression;\n\n        if (typeof expression == 'string')\n            expression = reducer.visitOData(expression);\n\n        result = reducer.evaluate(expression, it);\n\n        return result.type == ExpressionType.Literal ? (<ILiteralExpression>result).value : undefined;\n    }\n\n}"]}