{"version":3,"file":"reducervisitor.js","sourceRoot":"","sources":["../../../src/linq/expressions/reducervisitor.ts"],"names":[],"mappings":"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","sourcesContent":["import { IExpression, Expression, ExpressionType } from './expression';\r\nimport { ILiteralExpression, LiteralExpression } from './literalexpression';\r\nimport { ICompoundExpression } from './compoundexpression';\r\nimport { IIdentifierExpression, IdentifierExpression } from './identifierexpression';\r\nimport { IMemberExpression, MemberExpression } from './memberexpression';\r\nimport { IMethodExpression, MethodExpression } from './methodexpression';\r\nimport { IUnaryExpression, UnaryExpression, UnaryOperatorType, UnaryAffixType } from './unaryexpression';\r\nimport { IBinaryExpression, BinaryExpression, BinaryOperatorType } from './binaryexpression';\r\nimport { ILogicalExpression, LogicalExpression, LogicalOperatorType } from './logicalexpression';\r\nimport { IConditionalExpression, ConditionalExpression } from './conditionalexpression';\r\nimport { IArrayExpression, ArrayExpression } from './arrayexpression';\r\nimport { IIndexExpression, IndexExpression } from './indexexpression';\r\nimport { ITemplateLiteralExpression, TemplateLiteralExpression } from './templateliteralexpression';\r\n\r\nimport { LambdaExpression } from './lambdaexpression';\r\nimport { ExpressionVisitor } from './expressionvisitor';\r\n\r\nexport class ReducerVisitor extends ExpressionVisitor {\r\n    private _parentExpressionStack: Array<IExpression> = [];\r\n    private _it: string = null;\r\n\r\n    constructor() {\r\n        super();\r\n    }\r\n\r\n    public get it(): string {\r\n        return this._it;\r\n    }\r\n\r\n    public visitLambda(predicate: (it: Object, ...param: Array<any>) => any, ...param: Array<any>): IExpression {\r\n        //this._isSolvable = true; // reset it as checks for solvability is done for each visit\r\n        this._it = null; // do not involve \"this\" at the moment, since evalute is using \"ReducerVisitor.it\" to find out the named \"this\" scope.\r\n\r\n        let expr = super.visitLambda(predicate),\r\n            vars = null;\r\n\r\n        if (param.length > 0)\r\n        {\r\n            if (this._lambdaExpression && this._lambdaExpression.parameters.length > 0)\r\n            {\r\n                vars = this._lambdaExpression.parameters.reduce((res, val, index) => {\r\n                    if (index > 0 && index <= param.length)\r\n                        res[val] = param[index - 1]\r\n\r\n                    return res;\r\n                }, {});\r\n            }\r\n        }\r\n\r\n        expr = this.evaluate.call(this, expr, vars);\r\n\r\n        this._it = this._lambdaExpression != null && this._lambdaExpression.parameters.length > 0 ? this._lambdaExpression.parameters[0] : null;\r\n\r\n        return expr;\r\n    }\r\n\r\n    public visitLiteral(expression: ILiteralExpression): IExpression {\r\n        return this.evaluate(expression);\r\n    }\r\n\r\n    public visitMethod(expression: IMethodExpression): IExpression {\r\n        let expr: IMethodExpression,\r\n            value: any;\r\n\r\n        expr = new MethodExpression(expression.name, expression.parameters.map((arg) => arg.accept(this)), expression.caller);\r\n\r\n        return expr;\r\n    }\r\n\r\n    public visitBinary(expression: IBinaryExpression): IExpression {\r\n        let left = expression.left,\r\n            right = expression.right; \r\n\r\n        if (left.type == ExpressionType.Literal && right.type == ExpressionType.Literal)\r\n        {\r\n            let leftValue = (<LiteralExpression>left).value,\r\n                rightValue = (<LiteralExpression>right).value;\r\n\r\n            switch (expression.operator) {\r\n                case BinaryOperatorType.Addition:\r\n                    return new LiteralExpression(leftValue + rightValue);\r\n\r\n                case BinaryOperatorType.Subtraction:\r\n                    return new LiteralExpression(leftValue - rightValue);\r\n\r\n                case BinaryOperatorType.Multiplication:\r\n                    return new LiteralExpression(leftValue * rightValue);\r\n\r\n                case BinaryOperatorType.Division:\r\n                    return new LiteralExpression(leftValue / rightValue);\r\n\r\n                case BinaryOperatorType.Modulus:\r\n                    return new LiteralExpression(leftValue % rightValue);\r\n\r\n                case BinaryOperatorType.And:\r\n                    return new LiteralExpression(leftValue & rightValue);\r\n\r\n                case BinaryOperatorType.Or:\r\n                    return new LiteralExpression(leftValue | rightValue);\r\n\r\n                case BinaryOperatorType.ExclusiveOr:\r\n                    return new LiteralExpression(leftValue ^ rightValue);\r\n\r\n                case BinaryOperatorType.LeftShift:\r\n                    return new LiteralExpression(leftValue << rightValue);\r\n\r\n                case BinaryOperatorType.RightShift:\r\n                    return new LiteralExpression(leftValue >> rightValue);\r\n            }\r\n        }\r\n\r\n        return new BinaryExpression(expression.operator, left.accept(this), right.accept(this));\r\n    }\r\n\r\n    public visitConditional(expression: IConditionalExpression): IExpression {\r\n        let condition = expression.condition.accept(this);\r\n\r\n        if (condition.type == ExpressionType.Literal)\r\n        {\r\n            if ((<LiteralExpression>condition).value === true)\r\n                return expression.success.accept(this);\r\n            else\r\n                return expression.failure.accept(this);\r\n        }\r\n\r\n        return new ConditionalExpression(condition, expression.success.accept(this), expression.failure.accept(this));\r\n    }\r\n\r\n    public visitLogical(expression: ILogicalExpression): IExpression {\r\n        let left = expression.left.accept(this),\r\n            right = expression.right.accept(this);\r\n\r\n        if (left.type == ExpressionType.Literal && right.type == ExpressionType.Literal) {\r\n            let leftValue = (<LiteralExpression>left).value,\r\n                rightValue = (<LiteralExpression>right).value;\r\n\r\n            switch (expression.operator) {\r\n                case LogicalOperatorType.Equal:\r\n                    return new LiteralExpression(leftValue == rightValue);\r\n                case LogicalOperatorType.NotEqual:\r\n                    return new LiteralExpression(leftValue != rightValue);\r\n                case LogicalOperatorType.And:\r\n                    return new LiteralExpression(leftValue && rightValue);\r\n                case LogicalOperatorType.Or:\r\n                    return new LiteralExpression(leftValue || rightValue);\r\n                case LogicalOperatorType.Greater:\r\n                    return new LiteralExpression(leftValue > rightValue);\r\n                case LogicalOperatorType.GreaterOrEqual:\r\n                    return new LiteralExpression(leftValue >= rightValue);\r\n                case LogicalOperatorType.Lesser:\r\n                    return new LiteralExpression(leftValue < rightValue);\r\n                case LogicalOperatorType.LesserOrEqual:\r\n                    return new LiteralExpression(leftValue <= rightValue);\r\n            }\r\n        }\r\n\r\n        switch (expression.operator) {\r\n            case LogicalOperatorType.And:\r\n                if (left.type == ExpressionType.Literal && (<LiteralExpression>left).value === true) return right;\r\n                if (right.type == ExpressionType.Literal && (<LiteralExpression>right).value === true) return left;\r\n\r\n                break;\r\n\r\n            case LogicalOperatorType.Or:\r\n                if (left.type == ExpressionType.Literal && (<LiteralExpression>left).value === true) return left;\r\n                if (right.type == ExpressionType.Literal && (<LiteralExpression>right).value === true) return right;\r\n\r\n                break;\r\n        }\r\n\r\n        return new LogicalExpression(expression.operator, left, right);\r\n    }\r\n\r\n    public evaluate(expression: IExpression, it?: Object): IExpression \r\n    public evaluate(expression: IExpression, it: Object = null): IExpression {\r\n        if (expression == null)\r\n            return null;\r\n\r\n        var value: any = null;\r\n            \r\n\r\n        switch (expression.type) {\r\n            case ExpressionType.Literal: \r\n                break;\r\n\r\n            case ExpressionType.Identifier: {\r\n                var identifier = (<IIdentifierExpression>expression);\r\n\r\n                if (it != null)\r\n                {\r\n                    // this object\r\n                    if (it.hasOwnProperty(identifier.name) && (value = it[identifier.name]) != null)\r\n                    {\r\n                        switch (typeof value)\r\n                        {\r\n                            case 'string':\r\n                            case 'number':\r\n                                break;\r\n\r\n                            case 'object':\r\n                                if (value.getTime && value.getTime() >= 0)\r\n                                    break;\r\n\r\n                                if (Array.isArray(value) == true)\r\n                                    break;\r\n\r\n                            // fall through\r\n\r\n                            default:\r\n                                value = null;\r\n                        }\r\n\r\n                        return new LiteralExpression(value);\r\n                    }\r\n                }\r\n\r\n                break;\r\n            }\r\n\r\n            case ExpressionType.Array:\r\n                return new ArrayExpression((<IArrayExpression>expression).elements.map(v => this.evaluate(v, it)));\r\n            \r\n            case ExpressionType.Index: {\r\n                let object = this.evaluate((<IIndexExpression>expression).object, it),\r\n                    index = this.evaluate((<IIndexExpression>expression).index, it);\r\n\r\n                if (index.type == ExpressionType.Literal)\r\n                    switch (object.type)\r\n                    {\r\n                        case ExpressionType.Array:\r\n                            return Array.from((<IArrayExpression>object).elements)[(<ILiteralExpression>index).value];\r\n                            \r\n                        case ExpressionType.Literal:\r\n                            return new LiteralExpression(Array.from((<ILiteralExpression>object).value)[(<ILiteralExpression>index).value]);\r\n                    }\r\n\r\n                break;\r\n            }\r\n\r\n            case ExpressionType.Member: {\r\n                let object = (<IMemberExpression>expression).object,\r\n                    property = (<IMemberExpression>expression).property;\r\n\r\n                if (it != null)\r\n                {\r\n                    if (object.type == ExpressionType.Identifier)\r\n                    {\r\n                        if ((<IIdentifierExpression>object).name == 'this' || (<IIdentifierExpression>object).name == this.it)\r\n                        {\r\n                            value = this.evaluate(property, it);\r\n                            if (property.equal(value) == false)\r\n                                return value;\r\n                        }\r\n                        else\r\n                        {\r\n                            let descriptor = Object.getOwnPropertyDescriptor(it, (<IIdentifierExpression>object).name);\r\n                            if (descriptor && typeof descriptor.value == 'object')\r\n                            {\r\n                                value = this.evaluate(property, descriptor.value);\r\n                                if (property.equal(value) == false)\r\n                                    return value;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                break;\r\n            }\r\n\r\n            case ExpressionType.Conditional:\r\n                return this.visit(new ConditionalExpression(this.evaluate((<IConditionalExpression>expression).condition, it), this.evaluate((<IConditionalExpression>expression).success, it), this.evaluate((<IConditionalExpression>expression).failure, it)));\r\n\r\n            case ExpressionType.Logical:\r\n                return this.visit(new LogicalExpression((<ILogicalExpression>expression).operator, this.evaluate((<ILogicalExpression>expression).left, it), this.evaluate((<ILogicalExpression>expression).right, it)));\r\n\r\n            case ExpressionType.Binary:\r\n                return this.visit(new BinaryExpression((<IBinaryExpression>expression).operator, this.evaluate((<IBinaryExpression>expression).left, it), this.evaluate((<IBinaryExpression>expression).right, it)));\r\n\r\n            case ExpressionType.Method:\r\n                return this.visit(new MethodExpression((<IMethodExpression>expression).name, (<IMethodExpression>expression).parameters.map(p => this.evaluate(p, it)), this.evaluate((<IMethodExpression>expression).caller, it)));\r\n            \r\n            default:\r\n                let o = <IExpression>Object.create(Object.getPrototypeOf(expression), Object.getOwnPropertyNames(expression).reduce((prev, cur) => {\r\n                    let prop = Object.getOwnPropertyDescriptor(expression, cur);\r\n\r\n                    if (prop.value instanceof Expression)\r\n                        prop.value = this.evaluate(prop.value, it);\r\n                    else if (prop.value instanceof Array)\r\n                        prop.value = prop.value.map(a => a instanceof Expression ? this.evaluate(a, it) : a);\r\n\r\n                    prev[cur] = prop;\r\n\r\n                    return prev;\r\n                }, {}));\r\n\r\n                return this.visit(o);\r\n        }\r\n\r\n        return expression;\r\n    }\r\n\r\n    public static evaluate(expression: IExpression, it: Object = null): any {\r\n        let reducer = new ReducerVisitor(),\r\n            result = reducer.evaluate(expression, it);\r\n\r\n        return result.type == ExpressionType.Literal ? (<ILiteralExpression>result).value : undefined;\r\n    }\r\n\r\n    //private getInputParameters(): {} {\r\n    //    if (this._lambdaExpression && this._lambdaExpression.parameters.length > 0)\r\n    //        return this._lambdaExpression.parameters.reduce((res, val, index) => {\r\n    //            if (index > 0 && index <= this._params.length)\r\n    //                res[val] = this._params[index - 1]\r\n\r\n    //            return res;\r\n    //        }, {})\r\n\r\n    //    return {}\r\n    //}\r\n}\r\n\r\nexport { IExpression, Expression, ExpressionType } from './expression';\r\nexport { ILiteralExpression, LiteralExpression } from './literalexpression';\r\nexport { ICompoundExpression } from './compoundexpression';\r\nexport { IIdentifierExpression, IdentifierExpression } from './identifierexpression';\r\nexport { IMemberExpression, MemberExpression } from './memberexpression';\r\nexport { IMethodExpression, MethodExpression } from './methodexpression';\r\nexport { IUnaryExpression, UnaryExpression, UnaryOperatorType, UnaryAffixType } from './unaryexpression';\r\nexport { IBinaryExpression, BinaryExpression, BinaryOperatorType } from './binaryexpression';\r\nexport { ILogicalExpression, LogicalExpression, LogicalOperatorType } from './logicalexpression';\r\nexport { IConditionalExpression } from './conditionalexpression';\r\nexport { IArrayExpression, ArrayExpression } from './arrayexpression';"]}