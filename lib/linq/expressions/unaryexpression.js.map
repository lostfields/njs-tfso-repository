{"version":3,"file":"unaryexpression.js","sourceRoot":"","sources":["../../../src/linq/expressions/unaryexpression.ts"],"names":[],"mappings":";;AAAA,oEAAoG;AAiCzE,4BAjCA,oCAAiB,CAiCA;AAAE,yBAjCA,iCAAc,CAiCA;AAhC5D,6CAAuE;AAEvE,qBAA6B,SAAQ,uBAAU;IAC3C,YAAmB,QAA2B,EAAS,KAAqB,EAAS,QAAqB;QACtG,KAAK,CAAC,2BAAc,CAAC,KAAK,CAAC,CAAC;QADb,aAAQ,GAAR,QAAQ,CAAmB;QAAS,UAAK,GAAL,KAAK,CAAgB;QAAS,aAAQ,GAAR,QAAQ,CAAa;IAE1G,CAAC;IAEM,KAAK,CAAC,UAA4B;QACrC,MAAM,CAAC,CAAC,IAAI,CAAC,IAAI,IAAI,UAAU,CAAC,IAAI,IAAI,IAAI,CAAC,QAAQ,IAAI,UAAU,CAAC,QAAQ,IAAI,IAAI,CAAC,KAAK,IAAI,UAAU,CAAC,KAAK,IAAI,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC,CAAC;IAChK,CAAC;IAEM,QAAQ;QAEX,IAAI,QAAQ,GAAG,GAAG,EAAE;YAChB,MAAM,CAAA,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC;gBACnB,KAAK,oCAAiB,CAAC,UAAU,EAAE,MAAM,CAAC,GAAG,CAAC;gBAC9C,KAAK,oCAAiB,CAAC,MAAM,EAAE,MAAM,CAAC,GAAG,CAAC;gBAC1C,KAAK,oCAAiB,CAAC,QAAQ,EAAE,MAAM,CAAC,GAAG,CAAC;gBAC5C,KAAK,oCAAiB,CAAC,QAAQ,EAAE,MAAM,CAAC,GAAG,CAAC;gBAC5C,KAAK,oCAAiB,CAAC,SAAS,EAAE,MAAM,CAAC,IAAI,CAAC;gBAC9C,KAAK,oCAAiB,CAAC,SAAS,EAAE,MAAM,CAAC,IAAI,CAAC;YAClD,CAAC;QACL,CAAC,CAAA;QAED,EAAE,CAAA,CAAC,IAAI,CAAC,KAAK,IAAI,iCAAc,CAAC,MAAM,CAAC,CAAC,CAAC;YACrC,MAAM,CAAC,GAAG,QAAQ,EAAE,GAAG,IAAI,CAAC,QAAQ,CAAC,QAAQ,EAAE,EAAE,CAAC;QACtD,CAAC;QAAC,IAAI,CAAC,CAAC;YACJ,MAAM,CAAC,GAAG,IAAI,CAAC,QAAQ,CAAC,QAAQ,EAAE,GAAG,QAAQ,EAAE,EAAE,CAAC;QACtD,CAAC;IACL,CAAC;CACJ;AA5BD,0CA4BC","sourcesContent":["import { IUnaryExpression, UnaryOperatorType, UnaryAffixType } from './interfaces/iunaryexpression';\r\nimport { IExpression, Expression, ExpressionType } from './expression';\r\n\r\nexport class UnaryExpression extends Expression implements IUnaryExpression {\r\n    constructor(public operator: UnaryOperatorType, public affix: UnaryAffixType, public argument: IExpression) {\r\n        super(ExpressionType.Unary);\r\n    }\r\n\r\n    public equal(expression: IUnaryExpression) {\r\n        return (this.type == expression.type && this.operator == expression.operator && this.affix == expression.affix && this.argument.equal(expression.argument));\r\n    }\r\n\r\n    public toString() {\r\n\r\n        let operator = () => {\r\n            switch(this.operator) {\r\n                case UnaryOperatorType.Complement: return '~';\r\n                case UnaryOperatorType.Invert: return '!';\r\n                case UnaryOperatorType.Negative: return '-';\r\n                case UnaryOperatorType.Positive: return '+';\r\n                case UnaryOperatorType.Increment: return '++';\r\n                case UnaryOperatorType.Decrement: return '--';\r\n            }\r\n        }\r\n\r\n        if(this.affix == UnaryAffixType.Prefix) {\r\n            return `${operator()}${this.argument.toString()}`;\r\n        } else {\r\n            return `${this.argument.toString()}${operator()}`;\r\n        }\r\n    }\r\n}\r\n\r\nexport { IUnaryExpression, UnaryOperatorType, UnaryAffixType }"]}