{"version":3,"file":"expression.js","sourceRoot":"","sources":["../../../src/linq/expressions/expression.ts"],"names":[],"mappings":";;AAaA,IAAY,cAYX;AAZD,WAAY,cAAc;IACtB,2DAAQ,CAAA;IAER,+DAAU,CAAA;IACV,uDAAM,CAAA;IACN,yDAAO,CAAA;IACP,uDAAM,CAAA;IACN,qDAAK,CAAA;IACL,uDAAM,CAAA;IACN,yDAAO,CAAA;IACP,iEAAW,CAAA;IACX,qDAAK,CAAA;AACT,CAAC,EAZW,cAAc,GAAd,sBAAc,KAAd,sBAAc,QAYzB;AASD;IAGI,YAAY,IAAoB;QAC5B,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC;IACtB,CAAC;IAED,IAAI,IAAI;QACJ,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC;IACtB,CAAC;IAED,IAAI,IAAI,CAAC,KAAK;QACV,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;IACvB,CAAC;IAEM,MAAM,CAA8B,OAAU;QACjD,IAAI,UAAuB,CAAC;QAE5B,wDAAwD;QACxD,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAEzB,MAAM,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;YAChB,KAAK,cAAc,CAAC,OAAO;gBACvB,UAAU,GAAG,OAAO,CAAC,YAAY,CAA6B,IAAI,CAAC,CAAC;gBAAC,KAAK,CAAC;YAE/E,KAAK,cAAc,CAAC,QAAQ;gBACxB,UAAU,GAAG,OAAO,CAAC,aAAa,CAA8B,IAAI,CAAC,CAAC;gBAAC,KAAK,CAAC;YAEjF,KAAK,cAAc,CAAC,UAAU;gBAC1B,UAAU,GAAG,OAAO,CAAC,eAAe,CAAgC,IAAI,CAAC,CAAC;gBAAC,KAAK,CAAC;YAErF,KAAK,cAAc,CAAC,MAAM;gBACtB,UAAU,GAAG,OAAO,CAAC,WAAW,CAA4B,IAAI,CAAC,CAAC;gBAAC,KAAK,CAAC;YAE7E,KAAK,cAAc,CAAC,MAAM;gBACtB,UAAU,GAAG,OAAO,CAAC,WAAW,CAA4B,IAAI,CAAC,CAAC;gBAAC,KAAK,CAAC;YAE7E,KAAK,cAAc,CAAC,KAAK;gBACrB,UAAU,GAAG,OAAO,CAAC,UAAU,CAA2B,IAAI,CAAC,CAAC;gBAAC,KAAK,CAAC;YAE3E,KAAK,cAAc,CAAC,MAAM;gBACtB,UAAU,GAAG,OAAO,CAAC,WAAW,CAA4B,IAAI,CAAC,CAAC;gBAAC,KAAK,CAAC;YAE7E,KAAK,cAAc,CAAC,OAAO;gBACvB,UAAU,GAAG,OAAO,CAAC,YAAY,CAA6B,IAAI,CAAC,CAAC;gBAAC,KAAK,CAAC;YAE/E,KAAK,cAAc,CAAC,WAAW;gBAC3B,UAAU,GAAG,OAAO,CAAC,gBAAgB,CAAiC,IAAI,CAAC,CAAC;gBAAC,KAAK,CAAC;YAEvF,KAAK,cAAc,CAAC,KAAK;gBACrB,UAAU,GAAG,OAAO,CAAC,UAAU,CAA2B,IAAI,CAAC,CAAC;gBAAC,KAAK,CAAC;QAC/E,CAAC;QAED,uBAAuB;QACvB,OAAO,CAAC,KAAK,CAAC,GAAG,EAAE,CAAC;QAEpB,sCAAsC;QACtC,MAAM,CAAC,UAAU,CAAC;IACtB,CAAC;CAGJ;AA7DD,gCA6DC","sourcesContent":["import { ILiteralExpression } from './literalexpression';\r\nimport { ICompoundExpression } from './compoundexpression';\r\nimport { IIdentifierExpression } from './identifierexpression';\r\nimport { IMemberExpression } from './memberexpression';\r\nimport { IMethodExpression } from './methodexpression';\r\nimport { IUnaryExpression } from './unaryexpression';\r\nimport { IBinaryExpression } from './binaryexpression';\r\nimport { ILogicalExpression } from './logicalexpression';\r\nimport { IConditionalExpression } from './conditionalexpression';\r\nimport { IArrayExpression } from './arrayexpression';\r\n\r\nimport { ExpressionVisitor } from './expressionvisitor';\r\n\r\nexport enum ExpressionType {\r\n    Compound,\r\n\r\n    Identifier,\r\n    Member,\r\n    Literal,\r\n    Method,\r\n    Unary,\r\n    Binary,\r\n    Logical,\r\n    Conditional,\r\n    Array\r\n}\r\n\r\nexport interface IExpression {\r\n    type: ExpressionType\r\n\r\n    accept<T extends ExpressionVisitor>(visitor: T): IExpression\r\n    equal(expression: IExpression): boolean;\r\n}\r\n\r\nexport abstract class Expression implements IExpression {\r\n    private _type: ExpressionType;\r\n\r\n    constructor(type: ExpressionType) { //(predicate: (it: Object) => boolean, parameters?: any) {\r\n        this._type = type;\r\n    }\r\n\r\n    get type() {\r\n        return this._type;\r\n    }\r\n\r\n    set type(value) {\r\n        this._type = value;\r\n    }\r\n\r\n    public accept<T extends ExpressionVisitor>(visitor: T) {\r\n        let expression: IExpression;\r\n\r\n        // add this as parent to stack for next acceptance/visit\r\n        visitor.stack.push(this);\r\n\r\n        switch (this.type) {\r\n            case ExpressionType.Literal:\r\n                expression = visitor.visitLiteral(<ILiteralExpression><Object>this); break;\r\n\r\n            case ExpressionType.Compound:\r\n                expression = visitor.visitCompound(<ICompoundExpression><Object>this); break;\r\n\r\n            case ExpressionType.Identifier:\r\n                expression = visitor.visitIdentifier(<IIdentifierExpression><Object>this); break;\r\n\r\n            case ExpressionType.Member:\r\n                expression = visitor.visitMember(<IMemberExpression><Object>this); break;\r\n\r\n            case ExpressionType.Method:\r\n                expression = visitor.visitMethod(<IMethodExpression><Object>this); break;\r\n\r\n            case ExpressionType.Unary:\r\n                expression = visitor.visitUnary(<IUnaryExpression><Object>this); break;\r\n\r\n            case ExpressionType.Binary:\r\n                expression = visitor.visitBinary(<IBinaryExpression><Object>this); break;\r\n\r\n            case ExpressionType.Logical:\r\n                expression = visitor.visitLogical(<ILogicalExpression><Object>this); break;\r\n\r\n            case ExpressionType.Conditional:\r\n                expression = visitor.visitConditional(<IConditionalExpression><Object>this); break;\r\n\r\n            case ExpressionType.Array:\r\n                expression = visitor.visitArray(<IArrayExpression><Object>this); break;\r\n        }\r\n\r\n        // remove it from stack\r\n        visitor.stack.pop();\r\n\r\n        // return the newly visited expression\r\n        return expression;\r\n    }\r\n\r\n    public abstract equal(expression: IExpression): boolean\r\n}\r\n\r\nexport { ILiteralExpression, ICompoundExpression, IIdentifierExpression, IMemberExpression, IMethodExpression, IUnaryExpression, IBinaryExpression, ILogicalExpression, IConditionalExpression, IArrayExpression }\r\n"]}