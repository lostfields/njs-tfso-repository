{"version":3,"file":"templateliteralvisitor.js","sourceRoot":"","sources":["../../../src/linq/expressions/templateliteralvisitor.ts"],"names":[],"mappings":";;AAAA,6CAAuE;AACvE,2DAA4E;AAC5E,2EAAoG;AAEpG,2DAAwD;AAExD,4BAAoC,SAAQ,qCAAiB;IACzD,YAAoB,OAAgC;QAChD,KAAK,EAAE,CAAC;QADQ,YAAO,GAAP,OAAO,CAAyB;IAEpD,CAAC;IAED,oFAAoF;IACpF,gFAAgF;IAEhF,uEAAuE;IACvE,OAAO;IACP,0EAA0E;IAC1E,sFAAsF;IACtF,kBAAkB;IAClB,OAAO;IAEP,qDAAqD;IACrD,GAAG;IAEI,QAAQ,CAAC,UAAuB,EAAE,KAAa,IAAI;QACtD,IAAI,KAAK,GAAQ,IAAI,CAAC;QAEtB,EAAE,CAAC,CAAC,UAAU,IAAI,IAAI,CAAC;YACnB,MAAM,CAAC,IAAI,CAAC;QAEhB,MAAM,CAAC,CAAC,UAAU,CAAC,IAAI,CAAC,CACxB,CAAC;YACG,KAAK,2BAAc,CAAC,eAAe;gBAC/B,EAAE,CAAC,CAAC,EAAE,CAAC,CACP,CAAC;oBACG,IAAI,QAAQ,GAAgC,UAAW,CAAC,QAAQ,CAAC,GAAG,CAAC,EAAE,IAAI,IAAI,CAAC,QAAQ,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC,CAAC;oBAElG,EAAE,CAAC,CAAC,QAAQ,CAAC,KAAK,CAAC,EAAE,IAAI,EAAE,CAAC,IAAI,IAAI,2BAAc,CAAC,OAAO,CAAC,IAAI,IAAI,CAAC;wBAChE,MAAM,CAAC,IAAI,qCAAiB,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,GAAG,EAAE,EAAE,KAAK,GAAG,IAAI,MAAM,CAAsB,EAAG,CAAC,KAAK,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;oBAElH,MAAM,CAAC,IAAI,qDAAyB,CAAC,QAAQ,CAAC,CAAC;gBACnD,CAAC;gBACD,KAAK,CAAC;YAEV;gBACI,MAAM,CAAC,KAAK,CAAC,QAAQ,CAAC,UAAU,EAAE,EAAE,CAAC,CAAC;QAC9C,CAAC;QAED,MAAM,CAAC,UAAU,CAAC;IACtB,CAAC;IAIM,MAAM,CAAC,QAAQ,CAAC,UAAqE,EAAE,EAAU;QACpG,IAAI,OAAO,GAAG,IAAI,sBAAsB,EAAE,EACtC,MAAmB,CAAC;QAExB,EAAE,CAAC,CAAC,OAAO,UAAU,IAAI,UAAU,CAAC;YAChC,UAAU,GAAG,OAAO,CAAC,WAAW,CAAC,UAAU,CAAC,CAAC;QAEjD,MAAM,GAAG,OAAO,CAAC,QAAQ,CAAC,UAAU,EAAE,EAAE,CAAC,CAAC;QAE1C,MAAM,CAAC,MAAM,CAAC,IAAI,IAAI,2BAAc,CAAC,OAAO,GAAwB,MAAO,CAAC,KAAK,GAAG,SAAS,CAAC;IAClG,CAAC;CACJ;AA1DD,wDA0DC","sourcesContent":["import { IExpression, Expression, ExpressionType } from './expression';\nimport { ILiteralExpression, LiteralExpression } from './literalexpression';\nimport { ITemplateLiteralExpression, TemplateLiteralExpression } from './templateliteralexpression';\n\nimport { JavascriptVisitor } from './javascriptvisitor';\n\nexport class TemplateLiteralVisitor extends JavascriptVisitor {\n    constructor(private wrapper?: (value: any) => string) {\n        super();\n    }\n\n    //public visitTemplateLiteral(expression: ITemplateLiteralExpression): IExpression {\n    //    let elements = expression.elements.map((element) => element.accept(this));\n\n    //    if (elements.every(expr => expr.type == ExpressionType.Literal)) \n    //    {\n    //        return new LiteralExpression(elements.reduce((output, expr) => {\n    //            return output + new String((<ILiteralExpression>expr).value).toString();\n    //        }, ''));\n    //    }\n\n    //    return new TemplateLiteralExpression(elements);\n    //}\n\n    public evaluate(expression: IExpression, it: Object = null): IExpression {\n        var value: any = null;\n\n        if (expression == null)\n            return null;\n\n        switch (expression.type)\n        {\n            case ExpressionType.TemplateLiteral:\n                if (it)\n                {\n                    let elements = (<ITemplateLiteralExpression>expression).elements.map(el => this.evaluate(el, it));\n\n                    if (elements.every(el => el.type == ExpressionType.Literal) == true)\n                        return new LiteralExpression(elements.reduce((out, el) => out += String((<ILiteralExpression>el).value), ''));\n\n                    return new TemplateLiteralExpression(elements);\n                }\n                break;\n                \n            default:\n                return super.evaluate(expression, it);\n        }\n\n        return expression;\n    }\n\n    public static evaluate(predicate: (it: Object, ...param: Array<any>) => any, it: Object): any\n    public static evaluate(expression: IExpression, it: Object): any\n    public static evaluate(expression: IExpression | ((it: Object, ...param: Array<any>) => any), it: Object): any {\n        let reducer = new TemplateLiteralVisitor(),\n            result: IExpression;\n\n        if (typeof expression == 'function')\n            expression = reducer.visitLambda(expression);\n\n        result = reducer.evaluate(expression, it);\n\n        return result.type == ExpressionType.Literal ? (<ILiteralExpression>result).value : undefined;\n    }\n}"]}