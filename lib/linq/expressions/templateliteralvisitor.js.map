{"version":3,"file":"templateliteralvisitor.js","sourceRoot":"","sources":["../../../src/linq/expressions/templateliteralvisitor.ts"],"names":[],"mappings":";;AAAA,6CAAuE;AACvE,2DAA4E;AAG5E,2EAAoG;AACpG,yDAA0F;AAE1F,2DAAwD;AAExD,4BAAoC,SAAQ,qCAAiB;IAGzD,YAAY,OAAgC;QACxC,KAAK,EAAE,CAAC;QAER,IAAI,CAAC,QAAQ,GAAG,OAAO,IAAI,CAAC,CAAC,KAAU,KAAK,KAAK,CAAC,CAAC;IACvD,CAAC;IAED,oFAAoF;IACpF,gFAAgF;IAEhF,uEAAuE;IACvE,OAAO;IACP,0EAA0E;IAC1E,sFAAsF;IACtF,kBAAkB;IAClB,OAAO;IAEP,qDAAqD;IACrD,GAAG;IAEI,QAAQ,CAAC,UAAuB,EAAE,KAAa,IAAI;QACtD,IAAI,KAAK,GAAQ,IAAI,CAAC;QAEtB,EAAE,CAAC,CAAC,UAAU,IAAI,IAAI,CAAC;YACnB,MAAM,CAAC,IAAI,CAAC;QAEhB,MAAM,CAAC,CAAC,UAAU,CAAC,IAAI,CAAC,CACxB,CAAC;YACG,KAAK,2BAAc,CAAC,eAAe;gBAC/B,IAAI,QAAQ,GAAgC,UAAW,CAAC,QAAQ,CAAC,GAAG,CAAC,EAAE,IAAI,IAAI,CAAC,QAAQ,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC,CAAC;gBAElG,EAAE,CAAC,CAAC,EAAE,CAAC,CACP,CAAC;oBACG,EAAE,CAAC,CAAC,QAAQ,CAAC,KAAK,CAAC,EAAE,IAAI,EAAE,CAAC,IAAI,IAAI,2BAAc,CAAC,OAAO,CAAC,IAAI,IAAI,CAAC;wBAChE,MAAM,CAAC,IAAI,qCAAiB,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,GAAG,EAAE,EAAE,KAAK,GAAG,IAAI,IAAI,CAAC,QAAQ,CAAsB,EAAG,CAAC,KAAK,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;gBAC7H,CAAC;gBAED,MAAM,CAAC,IAAI,qDAAyB,CAAC,QAAQ,CAAC,CAAC;YAEnD,KAAK,2BAAc,CAAC,MAAM;gBACtB,IAAI,UAAU,GAAuB,UAAW,CAAC,UAAU,CAAC,GAAG,CAAC,EAAE,IAAI,CAAiB,EAAE,GAAG,EAAE,IAAI,CAAC,QAAQ,CAAC,EAAE,CAAC,GAAG,EAAE,EAAE,CAAC,EAAE,KAAK,EAAE,IAAI,CAAC,QAAQ,CAAC,EAAE,CAAC,KAAK,EAAE,EAAE,CAAC,EAAE,CAAA,CAAC,CAAC;gBAE/J,EAAE,CAAC,CAAC,EAAE,CAAC,CACP,CAAC;oBACG,EAAE,CAAC,CAAC,UAAU,CAAC,KAAK,CAAC,EAAE,IAAI,EAAE,CAAC,KAAK,CAAC,IAAI,IAAI,2BAAc,CAAC,OAAO,CAAC,IAAI,IAAI,CAAC;wBACxE,MAAM,CAAC,IAAI,qCAAiB,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC;4BAChD,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,IAAI,IAAI,2BAAc,CAAC,UAAU,GAA0B,CAAC,CAAC,GAAI,CAAC,IAAI,GAAwB,CAAC,CAAC,GAAI,CAAC,KAAK,CAAC,GAAwB,CAAC,CAAC,KAAM,CAAC,KAAK,CAAC;4BAC1J,MAAM,CAAC,CAAC,CAAC;wBACb,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;gBAChB,CAAC;gBAED,MAAM,CAAC,IAAI,mCAAgB,CAAC,UAAU,CAAC,CAAC;YAE5C;gBACI,MAAM,CAAC,KAAK,CAAC,QAAQ,CAAC,UAAU,EAAE,EAAE,CAAC,CAAC;QAC9C,CAAC;QAED,oBAAoB;IACxB,CAAC;IAIM,MAAM,CAAC,QAAQ,CAAC,UAAqE,EAAE,EAAU;QACpG,IAAI,OAAO,GAAG,IAAI,sBAAsB,EAAE,EACtC,MAAmB,CAAC;QAExB,EAAE,CAAC,CAAC,OAAO,UAAU,IAAI,UAAU,CAAC;YAChC,UAAU,GAAG,OAAO,CAAC,WAAW,CAAC,UAAU,CAAC,CAAC;QAEjD,MAAM,GAAG,OAAO,CAAC,QAAQ,CAAC,UAAU,EAAE,EAAE,CAAC,CAAC;QAE1C,MAAM,CAAC,MAAM,CAAC,IAAI,IAAI,2BAAc,CAAC,OAAO,GAAwB,MAAO,CAAC,KAAK,GAAG,SAAS,CAAC;IAClG,CAAC;CACJ;AA3ED,wDA2EC","sourcesContent":["import { IExpression, Expression, ExpressionType } from './expression';\nimport { ILiteralExpression, LiteralExpression } from './literalexpression';\nimport { IIdentifierExpression, IdentifierExpression } from './identifierexpression';\n\nimport { ITemplateLiteralExpression, TemplateLiteralExpression } from './templateliteralexpression';\nimport { IObjectExpression, ObjectExpression, IObjectProperty } from './objectexpression';\n\nimport { JavascriptVisitor } from './javascriptvisitor';\n\nexport class TemplateLiteralVisitor extends JavascriptVisitor {\n    private _wrapper: (value: any) => string;\n\n    constructor(wrapper?: (value: any) => string) {\n        super();\n\n        this._wrapper = wrapper || ((value: any) => value);\n    }\n\n    //public visitTemplateLiteral(expression: ITemplateLiteralExpression): IExpression {\n    //    let elements = expression.elements.map((element) => element.accept(this));\n\n    //    if (elements.every(expr => expr.type == ExpressionType.Literal)) \n    //    {\n    //        return new LiteralExpression(elements.reduce((output, expr) => {\n    //            return output + new String((<ILiteralExpression>expr).value).toString();\n    //        }, ''));\n    //    }\n\n    //    return new TemplateLiteralExpression(elements);\n    //}\n\n    public evaluate(expression: IExpression, it: Object = null): IExpression {\n        var value: any = null;\n\n        if (expression == null)\n            return null;\n\n        switch (expression.type)\n        {\n            case ExpressionType.TemplateLiteral:\n                let elements = (<ITemplateLiteralExpression>expression).elements.map(el => this.evaluate(el, it));\n\n                if (it)\n                {\n                    if (elements.every(el => el.type == ExpressionType.Literal) == true)\n                        return new LiteralExpression(elements.reduce((out, el) => out += this._wrapper((<ILiteralExpression>el).value), ''));\n                }\n\n                return new TemplateLiteralExpression(elements);\n\n            case ExpressionType.Object:\n                let properties = (<IObjectExpression>expression).properties.map(el => <IObjectProperty>{ key: this.evaluate(el.key, it), value: this.evaluate(el.value, it) });\n\n                if (it)\n                {\n                    if (properties.every(el => el.value.type == ExpressionType.Literal) == true)\n                        return new LiteralExpression(properties.reduce((o, p) => {\n                            o[p.key.type == ExpressionType.Identifier ? (<IdentifierExpression>p.key).name : (<ILiteralExpression>p.key).value] = (<ILiteralExpression>p.value).value;\n                            return o;\n                        }, {}));\n                }\n\n                return new ObjectExpression(properties);\n                \n            default:\n                return super.evaluate(expression, it);\n        }\n\n        //return expression;\n    }\n\n    public static evaluate(predicate: (it: Object, ...param: Array<any>) => any, it: Object): any\n    public static evaluate(expression: IExpression, it: Object): any\n    public static evaluate(expression: IExpression | ((it: Object, ...param: Array<any>) => any), it: Object): any {\n        let reducer = new TemplateLiteralVisitor(),\n            result: IExpression;\n\n        if (typeof expression == 'function')\n            expression = reducer.visitLambda(expression);\n\n        result = reducer.evaluate(expression, it);\n\n        return result.type == ExpressionType.Literal ? (<ILiteralExpression>result).value : undefined;\n    }\n}"]}