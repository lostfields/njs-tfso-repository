{"version":3,"file":"remapvisitor.js","sourceRoot":"","sources":["../../../src/linq/expressions/remapvisitor.ts"],"names":[],"mappings":"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","sourcesContent":["import { IExpression, Expression, ExpressionType } from './expression';\nimport { IIdentifierExpression, IdentifierExpression } from './identifierexpression';\nimport { IMemberExpression, MemberExpression } from './memberexpression';\nimport { ILogicalExpression, LogicalExpression, LogicalOperatorType } from './logicalexpression';\nimport { IMethodExpression } from './methodexpression';\nimport { ILiteralExpression, LiteralExpression } from './literalexpression';\n\nimport { ExpressionVisitor } from './expressionvisitor';\n\nexport class RemapVisitor extends ExpressionVisitor {\n    constructor(private remapKey: (name: string) => string, private remapValue: (name: string, value: any) => any) {\n        super();\n\n        if (typeof this.remapKey != 'function')\n            this.remapKey = null;\n\n        if (typeof this.remapValue != 'function')\n            this.remapValue = null;\n    }\n\n    public visit(expression: IExpression): IExpression {\n        return expression.accept(this);\n    }\n\n    public visitLiteral(expression: ILiteralExpression): IExpression {\n        let parent = this.stack.peek(),\n            property: IExpression,\n            value: any;\n        \n        if (this.remapValue && (property = this.findIdentifier(parent)) && (value = this.remapValue(this.flattenMember(property), expression.value)) !== undefined)\n            return new LiteralExpression(value);\n\n        return new LiteralExpression(expression.value)\n    }\n\n    public visitIdentifier(expression: IIdentifierExpression): IExpression {\n        let parent = this.stack.peek(),\n            name: string;\n\n        if (this.remapKey && parent.type != ExpressionType.Member) {\n            if ((name = this.remapKey(expression.name)) != null)\n                return new IdentifierExpression(name);\n        }\n\n        return new IdentifierExpression(expression.name);\n    }\n\n    public visitMember(expression: IMemberExpression): IExpression {       \n        let path: string;\n   \n        if (this.remapKey && (path = this.remapKey(this.flattenMember(expression))) != null)\n            return this.unflattenMember(path);\n\n        return new MemberExpression(expression.object.accept(this), expression.property.accept(this));\n    }\n\n    private findIdentifier(expression: IExpression): IExpression {\n        let member: any;\n\n        switch (expression.type) {\n            case ExpressionType.Logical:\n                if ((member = this.findIdentifier((<ILogicalExpression>expression).left)) != null)\n                    return member;\n\n                if ((member = this.findIdentifier((<ILogicalExpression>expression).right)) != null)\n                    return member;\n\n                break;\n\n            case ExpressionType.Identifier:\n                return expression;\n\n            case ExpressionType.Member:\n                return expression;\n\n            case ExpressionType.Method:\n                if ((<IMethodExpression>expression).caller != null && (member = this.findIdentifier((<IMethodExpression>expression).caller)) != null)\n                    return member;\n\n                if ((<IMethodExpression>expression).parameters.length >= 1 && (member = this.findIdentifier((<IMethodExpression>expression).parameters[0])) != null)\n                    return member;\n\n                break;\n        }\n\n        return null;\n    }\n\n    private flattenMember(expression: IExpression): string {\n        switch (expression.type) {\n            case ExpressionType.Member:\n                let prop = this.flattenMember((<IMemberExpression>expression).property);\n\n                return this.flattenMember((<IMemberExpression>expression).object) + (prop.length > 0 ? '.' + prop : '');\n                \n            case ExpressionType.Identifier:\n                return (<IIdentifierExpression>expression).name;\n\n            default:\n                return \"\";\n        }\n    }\n\n    private unflattenMember(path: string, idx: number = 0): IExpression {\n        let parts = path.split('.');\n\n        if (idx + 1 >= parts.length)\n            return new IdentifierExpression(parts[idx]);\n\n        return new MemberExpression(new IdentifierExpression(parts[idx]), this.unflattenMember(path, idx + 1));\n    }\n\n}\n"]}