{"version":3,"file":"enumerable.js","sourceRoot":"","sources":["../../src/linq/enumerable.ts"],"names":[],"mappings":"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","sourcesContent":["export interface IEnumerable<TEntity> extends Iterable<TEntity> {\r\n\r\n    /**\r\n    * Where clause using OData $filter expression returning either true or false. Any parameters used is properties of TEntity\r\n    * @param predicate OData expression\r\n    */\r\n    where(predicate: string): this\r\n    /**\r\n     * Where clause using Javascript expression returning either true or false\r\n     * @param predicate javascript expression\r\n     * @param parameters any javascript parameters has to be declared\r\n     */\r\n    where(predicate: (it: TEntity, ...param: any[]) => boolean, ...parameters: any[]): this\r\n\r\n    //orderBy(property: (it: TEntity) => void): this\r\n    //range(start: number, count: number): this\r\n    skip(count: number): this\r\n    take(count: number): this\r\n    //reverse(): this\r\n\r\n    first(items?: Array<TEntity>): TEntity\r\n    toArray(items: Array<TEntity>): Array<TEntity>\r\n    toArray(): Array<TEntity>\r\n\r\n    readonly operations: Operation<TEntity>\r\n}\r\n\r\nimport { Operator, OperatorType } from './operators/operator';\r\nimport { OrderByOperator } from './operators/orderbyoperator';\r\nimport { SkipOperator } from './operators/skipoperator';\r\nimport { TakeOperator } from './operators/takeoperator';\r\nimport { WhereOperator } from './operators/whereoperator';\r\n\r\nimport { RenameVisitor } from './expressions/renamevisitor';\r\n\r\nexport { OperatorType };\r\n\r\nexport class Operation<TEntity> {\r\n    private _stack: Array<Operator<TEntity>>;\r\n\r\n    constructor() {\r\n        this._stack = [];\r\n    }\r\n\r\n    public add(operator: Operator<TEntity>): void {\r\n        this._stack.push(operator);\r\n    }\r\n\r\n    public remove(operator: Operator<TEntity>): boolean {\r\n        var idx = this._stack.indexOf(operator);\r\n\r\n        if (idx != -1) {\r\n            this._stack.splice(idx, 1);\r\n\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    \r\n    public first<T extends Operator<TEntity>>(operator: { new (...args: any[]): T }): T\r\n    public first(operator: { new (...args: any[]): Operator<TEntity> }): Operator<TEntity>\r\n    public first(operatorType: OperatorType): Operator<TEntity> \r\n    public first(o: any): Operator<TEntity> {\r\n        for (let item of this.values())\r\n            if (item.type === o || (typeof o == 'function' && item instanceof o))\r\n                return item;\r\n\r\n        return null;\r\n    }\r\n\r\n    public* values(): IterableIterator<Operator<TEntity>> {\r\n        while (true) {\r\n            for (let item of this._stack) {\r\n                var reset = yield item;\r\n\r\n                if (reset === true)\r\n                    break;\r\n            }\r\n\r\n            if (reset !== true) // continue while loop if it's resetted\r\n                break;\r\n        }\r\n    }\r\n}\r\n\r\nexport default class Enumerable<TEntity> implements IEnumerable<TEntity>\r\n{\r\n    private _operations: Operation<TEntity>;\r\n    private _renames: Map<string, string> = new Map();\r\n\r\n    constructor(private items?: Array<TEntity>) {\r\n        this._operations = new Operation<TEntity>();\r\n    }\r\n\r\n    public rename(...values: Array<{ from: string, to: string }>): this { \r\n        // remap existing Identifiers/Members\r\n        let renameVisitor = new RenameVisitor(...values);\r\n\r\n        for (let item of this._operations.values()) {\r\n            switch (item.type) {\r\n                case OperatorType.Where:\r\n                    (<WhereOperator<TEntity>>item).expression = renameVisitor.visit((<WhereOperator<TEntity>>item).expression);\r\n                    break; \r\n            }\r\n        }\r\n       \r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Where clause using OData $filter expression returning either true or false. Any parameters used is properties of TEntity\r\n     * @param predicate OData expression\r\n     */\r\n    public where(predicate: string): this \r\n    /**\r\n     * Where clause using Javascript expression returning either true or false\r\n     * @param predicate javascript expression\r\n     * @param parameters any javascript parameters has to be declared\r\n     */\r\n    public where(predicate: (it: TEntity, ...param: any[]) => boolean, ...parameters: any[]): this\r\n    public where(): this {\r\n        let predicate: any = arguments[0],\r\n            parameters: Array<any> = [];\r\n\r\n        if (arguments.length >= 2)\r\n            parameters = Array.from(arguments).slice(1)\r\n\r\n        switch (typeof predicate) {\r\n            case 'string':\r\n                this._operations.add(new WhereOperator<TEntity>('OData', predicate));\r\n                break;\r\n\r\n            case 'function':\r\n                this._operations.add(new WhereOperator<TEntity>('Javascript', predicate, ...parameters));\r\n                break;\r\n\r\n            default:\r\n                throw new Error('Where operator can not recognize predicate either as javascript or odata');\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    public take(count: number): this {\r\n        this._operations.add(new TakeOperator<TEntity>(count));\r\n\r\n        return this;\r\n    }\r\n\r\n    public skip(count: number): this {\r\n        this._operations.add(new SkipOperator<TEntity>(count));\r\n\r\n        return this;\r\n    }\r\n\r\n    public orderBy(property: (it: TEntity) => void): this {\r\n        this._operations.add(new OrderByOperator<TEntity>(property));\r\n\r\n        return this;\r\n    }\r\n\r\n    public first(items?: Array<TEntity>): TEntity {\r\n        let result = this.toArray(items);\r\n\r\n        return result.length > 0 ? result[0] : null;\r\n    }\r\n\r\n    public toArray(items?: Array<TEntity>): Array<TEntity> {\r\n        let ar = items || this.items;\r\n\r\n        for (let item of this._operations.values())\r\n            ar = item.evaluate(ar);\r\n\r\n        return ar;\r\n    }\r\n\r\n    //public validateSequence(...operators: OperatorType[]): boolean {\r\n    //    let idx = -1;\r\n       \r\n    //    return operators.every(operator => {\r\n    //        let newIdx = 0;\r\n\r\n    //        newIdx = this._stack.findIndex(item => (item.type & operator) > 0)\r\n\r\n    //        if (newIdx == -1) {\r\n    //            return true;\r\n    //        } else if (newIdx > idx) {\r\n    //            idx = newIdx; return true;\r\n    //        } else {\r\n    //            return false;\r\n    //        }\r\n    //    });\r\n    //}\r\n\r\n    //public getFirstOperator(type: OperatorType): Operator<TEntity> {\r\n    //    for (let i = 0; i < this._stack.length; i++)\r\n    //        if (this._stack[i].type == type)\r\n    //            return this._stack[i];\r\n    //}\r\n\r\n    //public removeFirstOperator(type: OperatorType): Operator<TEntity> {\r\n    //    for (let i = 0; i < this._stack.length; i++)\r\n    //        if (this._stack[i].type == type)\r\n    //            return this._stack.splice(i, 1)[0];\r\n    //}\r\n\r\n    public get operations(): Operation<TEntity> {\r\n        return this._operations;\r\n    }\r\n\r\n    public static fromArray<TEntity>(items?: Array<TEntity>): Enumerable<TEntity> {\r\n        return new Enumerable(items);\r\n    }\r\n\r\n    [Symbol.iterator] = function* (): Iterator<TEntity> {\r\n        let counter = 0;\r\n        let result: Array<TEntity> = this.toArray();\r\n\r\n        while (true) {\r\n            for (let item of result) {\r\n                var reset = yield item;\r\n\r\n                if (reset === true)\r\n                    break;\r\n            }\r\n\r\n            if (reset !== true) // continue while loop if it's resetted\r\n                break;\r\n        }\r\n    }\r\n}\r\n"]}