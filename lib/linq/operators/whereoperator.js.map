{"version":3,"file":"whereoperator.js","sourceRoot":"","sources":["../../../src/linq/operators/whereoperator.ts"],"names":[],"mappings":"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","sourcesContent":["import { Operator, OperatorType } from './operator';\r\n\r\nimport { IExpression, ExpressionType } from './../expressions/expression';\r\nimport { ILogicalExpression, LogicalExpression, LogicalOperatorType } from './../expressions/logicalexpression';\r\nimport { MemberExpression } from './../expressions/memberexpression';\r\nimport { IdentifierExpression } from './../expressions/identifierexpression';\r\n\r\nimport { ReducerVisitor } from './../expressions/reducervisitor';\r\nimport { ODataVisitor } from './../expressions/odatavisitor';\r\n\r\nexport type PredicateType = 'Javascript' | 'OData';\r\n\r\nexport class WhereOperator<TEntity> extends Operator<TEntity> {\r\n    private _predicate: (entity: TEntity) => boolean;\r\n    private _expression: IExpression;\r\n\r\n    private _it: string;\r\n\r\n    private _footprint: string\r\n\r\n    constructor(predicateType: 'OData', predicate: string)\r\n    constructor(predicateType: 'Javascript', predicate: (it: TEntity, ...param: any[]) => boolean, ...parameters: Array<any>)\r\n    constructor(predicateType: PredicateType, predicate: any, ...parameters: any[]) {\r\n        super(OperatorType.Where);\r\n\r\n        //this._parameters = parameters;\r\n\r\n        switch (predicateType) {\r\n            case 'Javascript':\r\n                let visitor: ReducerVisitor;\r\n\r\n                this._expression = (visitor = new ReducerVisitor()).visitLambda(predicate, ...parameters);\r\n                this._it = visitor.it;\r\n\r\n                this._footprint = new Object(predicate).toString();\r\n                this._predicate = (entity: TEntity) => {\r\n                    return predicate.apply({}, [entity].concat(parameters)) === true;\r\n                };\r\n\r\n                //if (visitor.isSolvable == false)\r\n                //    throw new Error('Predicate is not solvable');\r\n\r\n                break;\r\n\r\n            case 'OData':\r\n                this._expression = new ODataVisitor().visitOData(predicate);\r\n                this._it = \"\";\r\n\r\n                this._footprint = predicate;\r\n                this._predicate = (entity: TEntity) => {\r\n                    return ODataVisitor.evaluate(this._expression, entity) === true;\r\n                }\r\n                \r\n                break;\r\n        }\r\n    }\r\n\r\n    //public get parameters(): any[] {\r\n    //    return this._parameters;\r\n    //}\r\n\r\n    public get predicate(): (entity: TEntity) => boolean {\r\n        return this._predicate == null ? () => true : this._predicate;\r\n    }\r\n\r\n    public get expression(): IExpression {\r\n        return this._expression;\r\n    }\r\n\r\n    public set expression(value: IExpression) {\r\n        this._expression = value;\r\n    }\r\n\r\n    public* evaluate(items: Iterable<TEntity>): IterableIterator<TEntity> {\r\n        for (let item of items)\r\n            if (this._predicate(item)) yield item;\r\n    }\r\n    \r\n    public async * evaluateAsync(items: AsyncIterable<TEntity>): AsyncIterableIterator<TEntity> {    \r\n        for await (let item of items)\r\n            if (this._predicate(item)) yield item;\r\n    }\r\n\r\n    public getExpressionIntersection(): ILogicalExpression[] {\r\n        let intersection: Array<ILogicalExpression>;\r\n\r\n        intersection = Array.from(this.getExpressionGroups()).reduce((acc, curr, idx) => {\r\n            return Array.from(curr).filter((expr) => {\r\n                return !acc || acc.some(intersect => expr.equal(intersect));\r\n            });\r\n        }, intersection);\r\n\r\n        return intersection || [];\r\n    }\r\n\r\n    public getExpressionUnion(): ILogicalExpression[] {\r\n        let union: Array<ILogicalExpression>;\r\n\r\n        union = Array.from(this.getExpressionGroups()).reduce((acc, curr, idx) => {\r\n            return (acc || []).concat(Array.from(curr));\r\n        }, union);\r\n\r\n        return union || [];\r\n    }\r\n\r\n    public getExpressionCount(): number {\r\n        let visit = (expression: IExpression) : number => {\r\n\r\n            switch (expression.type)\r\n            {\r\n                case ExpressionType.Logical:\r\n                    switch ((<LogicalExpression>expression).operator)\r\n                    {\r\n                        case LogicalOperatorType.And:\r\n                        case LogicalOperatorType.Or:\r\n                            return visit((<LogicalExpression>expression).left) + visit((<LogicalExpression>expression).right);\r\n\r\n                        default:\r\n                            return 1;\r\n                    }\r\n\r\n                default:\r\n                    return 0;\r\n            }\r\n        }\r\n\r\n        return visit(this.expression);\r\n    }\r\n\r\n    private getExpressionGroups(): Iterable<IterableIterator<ILogicalExpression>> {\r\n        let it = this._it,\r\n            visit = function* (expression: IExpression): Iterable<IterableIterator<ILogicalExpression>> {\r\n                let visitGroup = function* (child: LogicalExpression): IterableIterator<ILogicalExpression> {\r\n                    switch (child.operator) {\r\n                        case LogicalOperatorType.Or:\r\n                            break;\r\n\r\n                        case LogicalOperatorType.And:\r\n                            if (child.left instanceof LogicalExpression) yield* visitGroup(child.left);\r\n                            if (child.right instanceof LogicalExpression) yield* visitGroup(child.right);\r\n                            break;\r\n\r\n                        default:                      \r\n                            let reduceMemberToIdentifier = (expr: IExpression): IExpression => {\r\n                                switch (expr.type) {\r\n                                    case ExpressionType.Logical:\r\n                                        let left = reduceMemberToIdentifier((<LogicalExpression>expr).left),\r\n                                            right = reduceMemberToIdentifier((<LogicalExpression>expr).right);\r\n\r\n                                        if ((left.type == ExpressionType.Identifier || left.type == ExpressionType.Member || left.type == ExpressionType.Method) == false) {\r\n                                            switch ((<LogicalExpression>expr).operator) {\r\n                                                case LogicalOperatorType.And:\r\n                                                case LogicalOperatorType.Or:\r\n                                                case LogicalOperatorType.NotEqual:\r\n                                                case LogicalOperatorType.Equal:\r\n                                                    return new LogicalExpression((<LogicalExpression>expr).operator, left, right);\r\n\r\n                                                case LogicalOperatorType.Greater: // 5 > 2 == 2 < 5\r\n                                                    return new LogicalExpression(LogicalOperatorType.Lesser, right, left);\r\n\r\n                                                case LogicalOperatorType.GreaterOrEqual: // 5 >= 2 == 2 <= 5\r\n                                                    return new LogicalExpression(LogicalOperatorType.LesserOrEqual, right, left);\r\n\r\n                                                case LogicalOperatorType.Lesser: // 5 < 2 == 2 > 5\r\n                                                    return new LogicalExpression(LogicalOperatorType.Greater, right, left);\r\n\r\n                                                case LogicalOperatorType.LesserOrEqual: // 5 <= 2 == 2 >= 5\r\n                                                    return new LogicalExpression(LogicalOperatorType.GreaterOrEqual, right, left);\r\n                                            }\r\n                                        }\r\n\r\n                                        return new LogicalExpression((<LogicalExpression>expr).operator, left, right);\r\n\r\n                                    case ExpressionType.Member:\r\n                                        if ((<MemberExpression>expr).object.type == ExpressionType.Identifier && (<IdentifierExpression>(<MemberExpression>expr).object).name == it)\r\n                                            return (<MemberExpression>expr).property;\r\n                                        else\r\n                                            return expr;\r\n                                        \r\n                                    default:\r\n                                        return expr;\r\n                                }\r\n                            }\r\n\r\n                            let reduced = reduceMemberToIdentifier(child);\r\n                            if(reduced.type == ExpressionType.Logical)\r\n                                yield <ILogicalExpression>reduced;\r\n                    }\r\n                }\r\n\r\n                if (expression instanceof LogicalExpression) {\r\n                    if (expression.operator == LogicalOperatorType.Or) {\r\n                        yield* visit(expression.left);\r\n                        yield* visit(expression.right);\r\n                    }\r\n                    else {\r\n                        yield visitGroup(expression);\r\n                    }\r\n                }\r\n            };\r\n\r\n        // TODO; make a simplifier visitor that returns member expressions at left side an evaluates method call expressions (reduceMemberToIdentifier above does this now);\r\n        return visit(this.expression);\r\n    }\r\n\r\n    public toString(): string {\r\n        return this._footprint; // should be this._expression.toString() sooner or later\r\n    }\r\n\r\n    \r\n}"]}