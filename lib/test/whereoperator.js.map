{"version":3,"file":"whereoperator.js","sourceRoot":"","sources":["../../src/test/whereoperator.ts"],"names":[],"mappings":"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","sourcesContent":["import assert = require('assert');\n\nimport { WhereOperator } from './../linq/operators/whereoperator';\nimport { IExpression, ExpressionType  } from './../linq/expressions/expression';\nimport { ILogicalExpression, LogicalOperatorType } from './../linq/expressions/logicalexpression';\nimport { IIdentifierExpression } from './../linq/expressions/identifierexpression';\nimport { ILiteralExpression } from './../linq/expressions/literalexpression';\n\ninterface ICar {\n    id: number\n    location: string\n\n    registrationYear: number\n}\n\ndescribe(\"When using WhereOperator\", () => {\n    beforeEach(() => {\n\n    })\n\n    it(\"should intersect expression properties that is only and'ed\", () => {\n        let where = new WhereOperator<ICar>('Javascript', car => car.registrationYear == 2015 && car.location == 'NO' && car.id > 5),\n            intersection = where.getExpressionIntersection();\n\n        assert.equal(intersection.length, 3, \"Expected trhee expressions from intersection\");\n    });\n\n    it(\"should interesect expression properties that is common\", () => {\n        let where = new WhereOperator<ICar>('Javascript', car => (car.registrationYear == 2015 && car.location == 'NO') || car.registrationYear == 2015 || (car.location == 'SE' && car.registrationYear == 2015)),\n            intersection = where.getExpressionIntersection();\n\n        assert.equal(intersection.length, 1, \"Expected one expression from intersection\");\n        assert.equal(intersection[0].type, ExpressionType.Logical);\n        assert.equal((<ILogicalExpression>intersection[0]).operator, LogicalOperatorType.Equal);\n        assert.equal((<ILogicalExpression>intersection[0]).left.type, ExpressionType.Identifier);\n        assert.equal((<ILogicalExpression>intersection[0]).right.type, ExpressionType.Literal);\n    })\n\n    it(\"should interesect expression properties that is common but inverted\", () => {\n        let where = new WhereOperator<ICar>('Javascript', car => (car.registrationYear >= 2015 && car.location == 'NO') || 2015 <= car.registrationYear || (car.location == 'SE' && car.registrationYear >= 2015)),\n            intersection = where.getExpressionIntersection();\n\n        assert.equal(intersection.length, 1, \"Expected one expression from intersection\");\n        assert.equal(intersection[0].type, ExpressionType.Logical);\n        assert.equal((<ILogicalExpression>intersection[0]).operator, LogicalOperatorType.GreaterOrEqual);\n        assert.equal((<ILogicalExpression>intersection[0]).left.type, ExpressionType.Identifier);\n        assert.equal((<ILogicalExpression>intersection[0]).right.type, ExpressionType.Literal);\n    })\n\n    it(\"should interesect expression properties that is not common\", () => {\n        let where = new WhereOperator<ICar>('Javascript', car => (car.registrationYear > 2015 && car.location == 'NO') || car.registrationYear == 2015 || (car.location == 'SE' && car.registrationYear == 2015)),\n            intersection = where.getExpressionIntersection();\n\n        assert.equal(intersection.length, 0, \"Expected zero expressions from intersection\");\n    })\n\n    it(\"should intersect expression properties and simplify them\", () => {\n        let where = new WhereOperator<ICar>('Javascript', car => car.registrationYear >= 2015),\n            intersection = where.getExpressionIntersection();\n\n        assert.equal(intersection.length, 1, \"Expected one expression from intersection\");\n        assert.equal(intersection[0].type, ExpressionType.Logical);\n        assert.equal((<ILogicalExpression>intersection[0]).operator, LogicalOperatorType.GreaterOrEqual);\n\n        assert.equal((<ILogicalExpression>intersection[0]).left.type, ExpressionType.Identifier);\n        assert.equal((<IIdentifierExpression>(<ILogicalExpression>intersection[0]).left).name, \"registrationYear\");\n\n        assert.equal((<ILogicalExpression>intersection[0]).right.type, ExpressionType.Literal);\n        assert.equal((<ILiteralExpression>(<ILogicalExpression>intersection[0]).right).value, 2015);\n    });\n\n    it(\"should intersect inverted expression properties and simplify them\", () => {\n        let where = new WhereOperator<ICar>('Javascript', car => 2015 <= car.registrationYear),\n            intersection = where.getExpressionIntersection();\n\n        assert.equal(intersection.length, 1, \"Expected one expression from intersection\");\n        assert.equal(intersection[0].type, ExpressionType.Logical);\n        assert.equal((<ILogicalExpression>intersection[0]).operator, LogicalOperatorType.GreaterOrEqual);\n\n        assert.equal((<ILogicalExpression>intersection[0]).left.type, ExpressionType.Identifier);\n        assert.equal((<IIdentifierExpression>(<ILogicalExpression>intersection[0]).left).name, \"registrationYear\");\n\n        assert.equal((<ILogicalExpression>intersection[0]).right.type, ExpressionType.Literal);\n        assert.equal((<ILiteralExpression>(<ILogicalExpression>intersection[0]).right).value, 2015);\n    });\n\n    it(\"should intersect OData expression properties and simplify them\", () => {\n        let where = new WhereOperator<ICar>('OData', \"registrationYear ge 2015\"),\n            intersection = where.getExpressionIntersection();\n\n        assert.equal(intersection.length, 1, \"Expected one expression from intersection\");\n        assert.equal(intersection[0].type, ExpressionType.Logical);\n        assert.equal((<ILogicalExpression>intersection[0]).operator, LogicalOperatorType.GreaterOrEqual);\n\n        assert.equal((<ILogicalExpression>intersection[0]).left.type, ExpressionType.Identifier);\n        assert.equal((<IIdentifierExpression>(<ILogicalExpression>intersection[0]).left).name, \"registrationYear\");\n\n        assert.equal((<ILogicalExpression>intersection[0]).right.type, ExpressionType.Literal);\n        assert.equal((<ILiteralExpression>(<ILogicalExpression>intersection[0]).right).value, 2015);\n    });\n\n    it(\"should intersect inverted OData expression properties and simplify them\", () => {\n        let where = new WhereOperator<ICar>('OData', \"2015 le registrationYear\"),\n            intersection = where.getExpressionIntersection();\n\n        assert.equal(intersection.length, 1, \"Expected one expression from intersection\");\n        assert.equal(intersection[0].type, ExpressionType.Logical);\n        assert.equal((<ILogicalExpression>intersection[0]).operator, LogicalOperatorType.GreaterOrEqual);\n\n        assert.equal((<ILogicalExpression>intersection[0]).left.type, ExpressionType.Identifier);\n        assert.equal((<IIdentifierExpression>(<ILogicalExpression>intersection[0]).left).name, \"registrationYear\");\n\n        assert.equal((<ILogicalExpression>intersection[0]).right.type, ExpressionType.Literal);\n        assert.equal((<ILiteralExpression>(<ILogicalExpression>intersection[0]).right).value, 2015);\n    });\n});"]}