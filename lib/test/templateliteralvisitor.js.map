{"version":3,"file":"templateliteralvisitor.js","sourceRoot":"","sources":["../../src/test/templateliteralvisitor.ts"],"names":[],"mappings":"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","sourcesContent":["import * as assert from 'assert';\nimport * as Expr from './../linq/expressions/expressionvisitor';\nimport { TemplateLiteralVisitor } from './../linq/expressions/templateliteralvisitor';\n\ndescribe(\"When using TemplateLiteral for ExpressionVisitor\", () => {\n    var template: TemplateLiteralVisitor,\n        vars = { number: 5, array: [8, 7, 6, 5, 4, 3, 2, 1] }\n\n    beforeEach(() => {\n        template = new TemplateLiteralVisitor((value) => {\n            switch (typeof value)\n            {\n                case 'object':\n                    if ((<Object>value).hasOwnProperty('key'))\n                        return '<a href=\"#' + value['key'] + '\">' + value['value'] + '</a>';\n                    else\n                        return '<a href=\"#' + value['value'] + '\">' + value['value'] + '</a>';\n                        \n                default:\n                    return value;\n            }\n        });\n    })\n\n    var number = 5;\n\n    it(\"should handle a simple template literal\", () => {\n        let reduced = template.visitLambda(() => `My number is ${this.number} and my next is ${this.number + 1}`),\n            expr = template.evaluate(reduced, vars);\n\n        //assert.ok(template.isSolvable == true, \"Expected a solvable expression\");\n        assert.ok(expr.type == Expr.ExpressionType.Literal, \"Expected a literal\");\n        assert.ok((<Expr.ILiteralExpression>expr).value == 'My number is 5 and my next is 6');\n    })\n\n    it(\"should handle objects as expression\", () => {\n\n        let reduced = template.visitLambda(() => `My number is ${{ key: 0 + 1, value: this.number + 1 }} and my next is ${this.number + 1}`)\n            \n        assert.equal(reduced.type, Expr.ExpressionType.TemplateLiteral);\n        assert.equal((<Expr.ITemplateLiteralExpression>reduced).elements.length, 4);\n\n        assert.equal((<Expr.ITemplateLiteralExpression>reduced).elements[1].type, Expr.ExpressionType.Object);\n        assert.equal((<Expr.ITemplateLiteralExpression>reduced).elements[3].type, Expr.ExpressionType.Binary);\n\n        let expr = template.evaluate(reduced, vars);\n\n        assert.ok((<Expr.ILiteralExpression>expr).value == 'My number is <a href=\"#1\">6</a> and my next is 6');\n    })\n\n    it(\"should reduce it as much as possible\", () => {\n        let reduced = template.visitLambda(() => `My number is ${this.number} and my next is ${5 + 1}`)\n            \n        assert.equal(reduced.type, Expr.ExpressionType.TemplateLiteral);\n        assert.equal((<Expr.ITemplateLiteralExpression>reduced).elements.length, 4);\n\n        assert.equal((<Expr.ITemplateLiteralExpression>reduced).elements[3].type, Expr.ExpressionType.Literal);\n        assert.equal((<Expr.ILiteralExpression>(<Expr.ITemplateLiteralExpression>reduced).elements[3]).value, '6');\n\n        let compiled = template.evaluate(reduced, vars);\n        assert.ok((<Expr.ILiteralExpression>compiled).value == 'My number is 5 and my next is 6');\n    })\n\n    it(\"should handle the signature of tagged template literals\", () => {\n        let expr = template.visitLambda(() => `My number is ${5} and my next is ${5 + 1}`);\n        let es6literal = tag `My number is ${5} and my next is ${5 + 1}`\n\n        assert.equal(expr.type, Expr.ExpressionType.TemplateLiteral);\n        assert.equal((<Expr.ITemplateLiteralExpression>expr).elements.length, 4);\n\n        assert.equal((<Expr.ITemplateLiteralExpression>expr).literals.length, 2);\n        assert.equal((<Expr.ITemplateLiteralExpression>expr).expressions.length, 2);\n\n        for(let literal of (<Expr.ITemplateLiteralExpression>expr).literals)\n            assert.equal(literal.value, es6literal.literals.shift());\n\n        for(let expression of (<Expr.ITemplateLiteralExpression>expr).expressions)\n            assert.equal((<Expr.ILiteralExpression>expression).value, es6literal.expressions.shift());\n    })\n})\n\nfunction tag(parts: TemplateStringsArray, ...expressions: Array<any>) {\n    return {\n        literals: Array.from(parts),\n        expressions: Array.from(expressions)\n    }\n}"]}