{"version":3,"file":"odatavisitor.js","sourceRoot":"","sources":["../../src/test/odatavisitor.ts"],"names":[],"mappings":"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","sourcesContent":["import * as assert from 'assert';\nimport * as Expr from './../linq/expressions/expressionvisitor';\nimport { ODataVisitor } from './../linq/expressions/odatavisitor';\n\ndescribe(\"When using OData for ExpressionVisitor\", () => {\n    var reducer: ODataVisitor,\n        vars = { number: 5, string: 'abc', decimal: 5.50, date: new Date(\"2017-05-10T06:48:00Z\"), object: { number: 7 } }\n\n    beforeEach(() => {\n        reducer = new ODataVisitor();\n    })\n\n    it(\"should evaluate a simple expression with binary operation\", () => {\n        let reduced = reducer.visitOData(\"2 add 3\"),\n            expr = reducer.evaluate(reduced, vars);\n\n        assert.equal(expr.type, Expr.ExpressionType.Literal);\n        assert.equal((<Expr.LiteralExpression>expr).value, 5);\n    })\n\n    it(\"should evaluate a simple expression with binary operation and identifier\", () => {\n        let reduced = reducer.visitOData(\"2 add number\"),\n            expr = reducer.evaluate(reduced, vars);\n\n        assert.equal(expr.type, Expr.ExpressionType.Literal);\n        assert.equal((<Expr.LiteralExpression>expr).value, 7);\n    })\n\n    it(\"should evaluate a expression with binary operation and method 'length' with Identifier Expression\", () => {\n        let reduced = reducer.visitOData(\"2 add length(string)\"),\n            expr = reducer.evaluate(reduced, vars);\n\n        assert.equal(expr.type, Expr.ExpressionType.Literal);\n        assert.equal((<Expr.LiteralExpression>expr).value, 5);\n    })\n\n    it(\"should evaluate a expression with binary operation and method 'floor' with Identifier Expression\", () => {\n        let reduced = reducer.visitOData(\"2 add floor(decimal)\"),\n            expr = reducer.evaluate(reduced, vars);\n\n        assert.equal(expr.type, Expr.ExpressionType.Literal);\n        assert.equal((<Expr.LiteralExpression>expr).value, 7);\n    })\n\n    it(\"should evaluate a expression with binary operation and method 'ceiling' with Identifier Expression\", () => {\n        let reduced = reducer.visitOData(\"2 add ceiling(decimal)\"),\n            expr = reducer.evaluate(reduced, vars);\n\n        assert.equal(expr.type, Expr.ExpressionType.Literal);\n        assert.equal((<Expr.LiteralExpression>expr).value, 8);\n    })\n\n    it(\"should evaluate a expression with binary operation and method 'ceiling' with Literal Expression\", () => {\n        let reduced = reducer.visitOData(\"2 add ceiling(5.50)\"),\n            expr = reducer.evaluate(reduced, vars);\n\n        assert.equal(expr.type, Expr.ExpressionType.Literal);\n        assert.equal((<Expr.LiteralExpression>expr).value, 8);\n    })\n\n    it(\"should evaluate a expression with date as type (v4)\", () => {\n        let reduced = reducer.visitOData(\"date ge 2017-05-01Z\"),\n            expr = reducer.evaluate(reduced, vars);\n\n        assert.equal(expr.type, Expr.ExpressionType.Literal);\n        assert.equal((<Expr.LiteralExpression>expr).value, true);\n    })\n\n    it(\"should evaluate a expression with date as type for lesser (v4)\", () => {\n        let reduced = reducer.visitOData(\"date le 2017-05-20Z\"),\n            expr = reducer.evaluate(reduced, vars);\n\n        assert.equal(expr.type, Expr.ExpressionType.Literal);\n        assert.equal((<Expr.LiteralExpression>expr).value, true);\n    })\n\n    it(\"should evaluate a expression with datetime as type (v4)\", () => {\n        let reduced = reducer.visitOData(\"date ge 2017-05-01T12:00:00Z\"),\n            expr = reducer.evaluate(reduced, vars);\n\n        assert.equal(expr.type, Expr.ExpressionType.Literal);\n        assert.equal((<Expr.LiteralExpression>expr).value, true);\n    })\n\n    it(\"should evaluate a expression with date as string\", () => {\n        let reduced = reducer.visitOData(\"date ge '2017-05-01Z'\"),\n            expr = reducer.evaluate(reduced, vars);\n\n        assert.equal(expr.type, Expr.ExpressionType.Literal);\n        assert.equal((<Expr.LiteralExpression>expr).value, true);\n    })\n\n    it(\"should evaluate a expression with datetime as string\", () => {\n        let reduced = reducer.visitOData(\"date ge '2017-05-01T12:00:00Z'\"),\n            expr = reducer.evaluate(reduced, vars);\n\n        assert.equal(expr.type, Expr.ExpressionType.Literal);\n        assert.equal((<Expr.LiteralExpression>expr).value, true);\n    })\n\n    it(\"should evaluate a expression with binary operation and method 'year' with a Date type\", () => {\n        let reduced = reducer.visitOData(\"year(date) sub year(2016-05-01)\"),\n            expr = reducer.evaluate(reduced, vars);\n\n        assert.equal(expr.type, Expr.ExpressionType.Literal);\n        assert.equal((<Expr.LiteralExpression>expr).value, 1);\n    })\n\n    it(\"should evaluate a complex expression with binary operation and method 'year' with a Date type\", () => {\n        let reduced = reducer.visitOData(\"(number add 2012) sub year(2016-05-01)\"),\n            expr = reducer.evaluate(reduced, vars);\n\n        assert.equal(expr.type, Expr.ExpressionType.Literal);\n        assert.equal((<Expr.LiteralExpression>expr).value, 1);\n    })\n\n    it(\"should evaluate a complex expression that is using casing\", () => {\n        let reduced = reducer.visitOData(\"(number Add 2012) SUB year(2016-05-01)\"),\n            expr = reducer.evaluate(reduced, vars);\n\n        assert.equal(expr.type, Expr.ExpressionType.Literal);\n        assert.equal((<Expr.LiteralExpression>expr).value, 1);\n    })\n\n    it(\"should evaluate a complex expression with binary operation\", () => {\n\n        let reduced = reducer.visitOData(\"number ge 5 and number lt 10\"),\n            expr = reducer.evaluate(reduced, vars);\n\n        assert.ok(expr.type == Expr.ExpressionType.Literal, \"Expected a literal\");\n        assert.ok((<Expr.ILiteralExpression>expr).value == true, \"Expected a literal of value true\");\n    })\n\n    it(\"should evaluate a complex expression with binary operation using object\", () => {\n\n        let reduced = reducer.visitOData(\"object/number ge 7 and object/number lt 10 and number eq 5\"),\n            expr = reducer.evaluate(reduced, vars);\n\n        assert.ok(expr.type == Expr.ExpressionType.Literal, \"Expected a literal\");\n        assert.ok((<Expr.ILiteralExpression>expr).value == true, \"Expected a literal of value true\");\n    })\n})"]}