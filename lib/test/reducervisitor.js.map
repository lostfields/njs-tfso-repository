{"version":3,"file":"reducervisitor.js","sourceRoot":"","sources":["../../src/test/reducervisitor.ts"],"names":[],"mappings":"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","sourcesContent":["import * as assert from 'assert';\r\nimport * as Expr from './../linq/expressions/expressionvisitor';\r\nimport { ReducerVisitor } from './../linq/expressions/reducervisitor';\r\n\r\ndescribe(\"When using Reducer for ExpressionVisitor\", () => {\r\n    var reducer: ReducerVisitor,\r\n        expr: Expr.IExpression;\r\n\r\n    beforeEach(() => {\r\n        reducer = new ReducerVisitor({ number: 5 });\r\n    })\r\n\r\n    it(\"should evaluate a simple expression with binary operation\", () => {\r\n\r\n        expr = reducer.visitLambda(() => 2 + 3);\r\n\r\n        assert.ok(expr.type == Expr.ExpressionType.Literal, \"Expected a literal\");\r\n        assert.ok((<Expr.ILiteralExpression>expr).value == 5, \"Expected a literal of value 5\");\r\n    })\r\n\r\n    it(\"should evaluate a expression with binary operation\", () => {\r\n\r\n        expr = reducer.visitLambda(() => this.number + 3);\r\n\r\n        assert.ok(expr.type == Expr.ExpressionType.Literal, \"Expected a literal\");\r\n        assert.ok((<Expr.ILiteralExpression>expr).value == 8, \"Expected a literal of value 8\");\r\n    })\r\n\r\n    it(\"should evaluate expression\", () => {\r\n\r\n        expr = reducer.visitLambda(() => this.number == 2 + 3);\r\n\r\n        assert.ok(expr.type == Expr.ExpressionType.Literal, \"Expected a literal\");\r\n        assert.ok((<Expr.ILiteralExpression>expr).value == true, \"Expected a literal of value 'true'\");\r\n    })\r\n\r\n    it(\"should reduce expresion to a minimal expression\", () => {\r\n\r\n        expr = reducer.visitLambda(() => this.unknown == 2 + 3);\r\n\r\n        assert.ok(expr.type == Expr.ExpressionType.Logical, \"Expected a logical expression\");\r\n        assert.ok((<Expr.ILogicalExpression>expr).operator == Expr.LogicalOperatorType.Equal, \"Expected a logical expression with operator equal\");\r\n        assert.ok((<Expr.ILogicalExpression>expr).left.type == Expr.ExpressionType.Member, \"Expected a member expression at left side\");\r\n        assert.ok((<Expr.ILogicalExpression>expr).right.type == Expr.ExpressionType.Literal, \"Expected a literal expression at right side\");\r\n        assert.ok((<Expr.ILiteralExpression>(<Expr.ILogicalExpression>expr).right).value == 5, \"Expected a literal expression at right side of value 5\");\r\n    })\r\n\r\n    it(\"should have a solvable expression using valid scope\", () => {\r\n\r\n        expr = reducer.visitLambda(() => this.number == 2 + 3);\r\n\r\n        assert.ok(reducer.isSolvable == true, \"Expected a solvable expression\");\r\n        assert.ok(expr.type == Expr.ExpressionType.Literal, \"Expected a literal expression\");\r\n        assert.ok((<Expr.ILiteralExpression>expr).value == true, \"Expected the literal value to be true\");\r\n    })\r\n\r\n    it(\"should have a solvable expression using valid scope\", () => {\r\n\r\n        expr = reducer.visitLambda(() => this.number == 2 + 3);\r\n\r\n        assert.ok(reducer.isSolvable == true, \"Expected a solvable expression\");\r\n    })\r\n\r\n    it(\"should have a unsolvable expression using unknown scope\", () => {\r\n        expr = reducer.visitLambda(() => this.unknown == 2 + 3);\r\n\r\n        assert.ok(reducer.isSolvable == false, \"Expected a unsolvable expression\");\r\n    })\r\n\r\n    it(\"should have a unsolvable expression using valid scope that isn't passed in\", () => {\r\n\r\n        reducer = new ReducerVisitor();\r\n        expr = reducer.visitLambda(() => this.number == 2 + 3);\r\n\r\n        assert.ok(reducer.isSolvable == false, \"Expected a unsolvable expression\");\r\n    })\r\n\r\n    it(\"should have a solvable expression using valid scope that is passed in\", () => {\r\n\r\n        reducer = new ReducerVisitor();\r\n        expr = reducer.visitLambda(() => this.number == 2 + 3, { number: 5 });\r\n\r\n        assert.ok(reducer.isSolvable == true, \"Expected a solvable expression\");\r\n        assert.ok(expr.type == Expr.ExpressionType.Literal, \"Expected a literal\");\r\n        assert.ok((<Expr.ILiteralExpression>expr).value == true, \"Expected a literal of value 'true'\");\r\n    })\r\n\r\n    it(\"should have a solvable expression using valid parameter\", () => {\r\n\r\n        expr = reducer.visitLambda((myobject: any) => myobject.number == 2 + 3);\r\n\r\n        assert.ok(reducer.isSolvable == true, \"Expected a solvable expression\");\r\n    })\r\n\r\n    it(\"should have a solvable expression using named parameters\", () => {\r\n\r\n        expr = reducer.visitLambda((myobject: any, num: number, letter: string) => myobject.number == 2 + 3 && num == 5 && letter == 'a', 5, 'a');\r\n\r\n        assert.ok(reducer.isSolvable == true, \"Expected a solvable expression\");\r\n        assert.ok(expr.type == Expr.ExpressionType.Logical, \"Expected a logical expression\");\r\n\r\n    })\r\n})\r\n"]}