{"version":3,"file":"filters.js","sourceRoot":"","sources":["../../../src/repository/filters/filters.ts"],"names":[],"mappings":";;AAAA,qCAA2C;AAG3C,oEAAsG;AAStG;IAGI,YAAY,UAAuB;QAF3B,YAAO,GAAmB,EAAE,CAAC;QAGjC,EAAE,CAAC,CAAC,UAAU,IAAI,IAAI,IAAI,UAAU,CAAC,IAAI,IAAI,2BAAc,CAAC,OAAO,CAAC;YAChE,IAAI,CAAC,OAAO,GAAG,eAAM,CAAC,KAAK,CAAqB,UAAU,CAAC,CAAC;IACpE,CAAC;IAED,IAAW,MAAM;QACb,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC;IACxB,CAAC;IAEM,QAAQ;QACX,EAAE,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC,MAAM,IAAI,CAAC,CAAC;YACzB,MAAM,CAAC,IAAI,KAAK,EAAmB,CAAC;QAExC,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG;YACvC,MAAM,CAAC,IAAI,eAAM,CAAC,GAAG,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC;QACvD,CAAC,CAAC,CAAC,QAAQ,CAAC;IAChB,CAAC;IAEM,eAAe;QAClB,EAAE,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,IAAI,CAAC,CAAC;YACxB,MAAM,CAAC,IAAI,KAAK,EAAmB,CAAC;QAExC,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG;YACvC,IAAI,QAAQ,GAAG,GAAG,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,QAAQ;gBACxC,GAAG,CAAC,CAAC,IAAI,IAAI,IAAI,CAAC,CAAC,QAAQ,CAAC;oBACxB,EAAE,CAAC,CAAC,QAAQ,CAAC,QAAQ,IAAI,IAAI,CAAC,QAAQ,IAAI,QAAQ,CAAC,QAAQ,IAAI,IAAI,CAAC,QAAQ,IAAI,QAAQ,CAAC,KAAK,IAAI,IAAI,CAAC,KAAK,CAAC;wBAAC,MAAM,CAAC,IAAI,CAAC;gBAE9H,MAAM,CAAC,KAAK,CAAC;YACjB,CAAC,CAAC,CAAA;YAEF,MAAM,CAAC,IAAI,eAAM,CAAC,QAAQ,CAAC,CAAC;QAChC,CAAC,CAAC,CAAC,QAAQ,CAAA;IACf,CAAC;CACJ;AApCD,0BAoCC","sourcesContent":["import { IFilter, Filter } from './filter';\r\nimport { IFilterCriteria, FilterCriteria } from './filtercriteria';\r\n\r\nimport { IExpression, ExpressionType, ILogicalExpression } from './../../linq/expressions/expression';\r\n\r\nexport interface IFilters {\r\n    groups: Array<IFilter>\r\n\r\n    getUnion(): Array<IFilterCriteria>\r\n    getIntersection(): Array<IFilterCriteria>\r\n}\r\n\r\nexport class Filters<TEntity> implements IFilters {\r\n    private _groups: Array<IFilter> = [];\r\n\r\n    constructor(expression: IExpression) {\r\n        if (expression != null && expression.type == ExpressionType.Logical)\r\n            this._groups = Filter.visit(<ILogicalExpression>expression);\r\n    }\r\n\r\n    public get groups() {\r\n        return this._groups;\r\n    }\r\n\r\n    public getUnion() {\r\n        if (this._groups.length == 0)\r\n            return new Array<IFilterCriteria>();\r\n\r\n        return this.groups.reduce((res, v, idx, arr) => {\r\n            return new Filter(res.criteria.concat(v.criteria));\r\n        }).criteria;\r\n    }\r\n\r\n    public getIntersection() {\r\n        if (this.groups.length == 0)\r\n            return new Array<IFilterCriteria>();\r\n\r\n        return this.groups.reduce((res, v, idx, arr) => {\r\n            var criteria = res.criteria.filter((criteria) => {\r\n                for (let crit of v.criteria)\r\n                    if (criteria.property == crit.property && criteria.operator == crit.operator && criteria.value == crit.value) return true;\r\n\r\n                return false;\r\n            })\r\n\r\n            return new Filter(criteria);\r\n        }).criteria\r\n    }\r\n}"]}